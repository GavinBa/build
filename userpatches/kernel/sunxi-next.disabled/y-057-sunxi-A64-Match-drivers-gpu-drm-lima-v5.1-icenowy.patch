diff --git a/drivers/gpu/drm/lima/Kconfig b/drivers/gpu/drm/lima/Kconfig
deleted file mode 100644
index 89d63cca8..000000000
--- a/drivers/gpu/drm/lima/Kconfig
+++ /dev/null
@@ -1,10 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0 OR MIT
-# Copyright 2017-2018 Qiang Yu <yuq825@gmail.com>
-
-config DRM_LIMA
-       tristate "LIMA (DRM support for ARM Mali 400/450 GPU)"
-       depends on DRM
-       select DRM_SCHED
-       select DRM_TTM
-       help
-         DRM driver for ARM Mali 400/450 GPUs.
diff --git a/drivers/gpu/drm/lima/Makefile b/drivers/gpu/drm/lima/Makefile
deleted file mode 100644
index 8bb97410d..000000000
--- a/drivers/gpu/drm/lima/Makefile
+++ /dev/null
@@ -1,22 +0,0 @@
-# SPDX-License-Identifier: GPL-2.0 OR MIT
-# Copyright 2017-2018 Qiang Yu <yuq825@gmail.com>
-
-lima-y := \
-	lima_drv.o \
-	lima_device.o \
-	lima_pmu.o \
-	lima_l2_cache.o \
-	lima_mmu.o \
-	lima_gp.o \
-	lima_pp.o \
-	lima_gem.o \
-	lima_vm.o \
-	lima_sched.o \
-	lima_ctx.o \
-	lima_gem_prime.o \
-	lima_dlbu.o \
-	lima_bcast.o \
-	lima_ttm.o \
-	lima_object.o
-
-obj-$(CONFIG_DRM_LIMA) += lima.o
diff --git a/drivers/gpu/drm/lima/lima_bcast.c b/drivers/gpu/drm/lima/lima_bcast.c
index 63754f646..288398027 100644
--- a/drivers/gpu/drm/lima/lima_bcast.c
+++ b/drivers/gpu/drm/lima/lima_bcast.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0 OR MIT
-/* Copyright 2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2018-2019 Qiang Yu <yuq825@gmail.com> */
 
 #include <linux/io.h>
 #include <linux/device.h>
@@ -8,21 +8,22 @@
 #include "lima_bcast.h"
 #include "lima_regs.h"
 
-#define bcast_write(reg, data) writel(data, ip->iomem + LIMA_BCAST_##reg)
-#define bcast_read(reg) readl(ip->iomem + LIMA_BCAST_##reg)
+#define bcast_write(reg, data) writel(data, ip->iomem + reg)
+#define bcast_read(reg) readl(ip->iomem + reg)
 
 void lima_bcast_enable(struct lima_device *dev, int num_pp)
 {
 	struct lima_sched_pipe *pipe = dev->pipe + lima_pipe_pp;
 	struct lima_ip *ip = dev->ip + lima_ip_bcast;
-	int i, mask = bcast_read(BROADCAST_MASK) & 0xffff0000;
+	int i, mask = bcast_read(LIMA_BCAST_BROADCAST_MASK) & 0xffff0000;
 
 	for (i = 0; i < num_pp; i++) {
 		struct lima_ip *pp = pipe->processor[i];
+
 		mask |= 1 << (pp->id - lima_ip_pp0);
 	}
 
-	bcast_write(BROADCAST_MASK, mask);
+	bcast_write(LIMA_BCAST_BROADCAST_MASK, mask);
 }
 
 int lima_bcast_init(struct lima_ip *ip)
@@ -34,13 +35,13 @@ int lima_bcast_init(struct lima_ip *ip)
 			mask |= 1 << (i - lima_ip_pp0);
 	}
 
-	bcast_write(BROADCAST_MASK, mask << 16);
-	bcast_write(INTERRUPT_MASK, mask);
+	bcast_write(LIMA_BCAST_BROADCAST_MASK, mask << 16);
+	bcast_write(LIMA_BCAST_INTERRUPT_MASK, mask);
 	return 0;
 }
 
 void lima_bcast_fini(struct lima_ip *ip)
 {
-	
+
 }
 
diff --git a/drivers/gpu/drm/lima/lima_bcast.h b/drivers/gpu/drm/lima/lima_bcast.h
index 345e3e809..c47e58563 100644
--- a/drivers/gpu/drm/lima/lima_bcast.h
+++ b/drivers/gpu/drm/lima/lima_bcast.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0 OR MIT */
-/* Copyright 2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2018-2019 Qiang Yu <yuq825@gmail.com> */
 
 #ifndef __LIMA_BCAST_H__
 #define __LIMA_BCAST_H__
diff --git a/drivers/gpu/drm/lima/lima_ctx.c b/drivers/gpu/drm/lima/lima_ctx.c
index 3f8a944d9..22fff6caa 100644
--- a/drivers/gpu/drm/lima/lima_ctx.c
+++ b/drivers/gpu/drm/lima/lima_ctx.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0 OR MIT
-/* Copyright 2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2018-2019 Qiang Yu <yuq825@gmail.com> */
 
 #include <linux/slab.h>
 
@@ -23,15 +23,10 @@ int lima_ctx_create(struct lima_device *dev, struct lima_ctx_mgr *mgr, u32 *id)
 			goto err_out0;
 	}
 
-	idr_preload(GFP_KERNEL);
-	spin_lock(&mgr->lock);
-	err = idr_alloc(&mgr->handles, ctx, 1, 0, GFP_ATOMIC);
-	spin_unlock(&mgr->lock);
-	idr_preload_end();
+	err = xa_alloc(&mgr->handles, id, ctx, xa_limit_32b, GFP_KERNEL);
 	if (err < 0)
 		goto err_out0;
 
-	*id = err;
 	return 0;
 
 err_out0:
@@ -54,27 +49,27 @@ static void lima_ctx_do_release(struct kref *ref)
 int lima_ctx_free(struct lima_ctx_mgr *mgr, u32 id)
 {
 	struct lima_ctx *ctx;
+	int ret = 0;
 
-	spin_lock(&mgr->lock);
-	ctx = idr_remove(&mgr->handles, id);
-	spin_unlock(&mgr->lock);
-
-	if (ctx) {
+	mutex_lock(&mgr->lock);
+	ctx = xa_erase(&mgr->handles, id);
+	if (ctx)
 		kref_put(&ctx->refcnt, lima_ctx_do_release);
-		return 0;
-	}
-	return -EINVAL;
+	else
+		ret = -EINVAL;
+	mutex_unlock(&mgr->lock);
+	return ret;
 }
 
 struct lima_ctx *lima_ctx_get(struct lima_ctx_mgr *mgr, u32 id)
 {
 	struct lima_ctx *ctx;
 
-	spin_lock(&mgr->lock);
-	ctx = idr_find(&mgr->handles, id);
+	mutex_lock(&mgr->lock);
+	ctx = xa_load(&mgr->handles, id);
 	if (ctx)
 		kref_get(&ctx->refcnt);
-	spin_unlock(&mgr->lock);
+	mutex_unlock(&mgr->lock);
 	return ctx;
 }
 
@@ -85,40 +80,19 @@ void lima_ctx_put(struct lima_ctx *ctx)
 
 void lima_ctx_mgr_init(struct lima_ctx_mgr *mgr)
 {
-        spin_lock_init(&mgr->lock);
-	idr_init(&mgr->handles);
+	mutex_init(&mgr->lock);
+	xa_init_flags(&mgr->handles, XA_FLAGS_ALLOC);
 }
 
 void lima_ctx_mgr_fini(struct lima_ctx_mgr *mgr)
 {
 	struct lima_ctx *ctx;
-	struct idr *idp;
-	uint32_t id;
+	unsigned long id;
 
-	idp = &mgr->handles;
-
-	idr_for_each_entry(idp, ctx, id) {
-	        kref_put(&ctx->refcnt, lima_ctx_do_release);
+	xa_for_each(&mgr->handles, id, ctx) {
+		kref_put(&ctx->refcnt, lima_ctx_do_release);
 	}
 
-	idr_destroy(&mgr->handles);
-}
-
-struct dma_fence *lima_ctx_get_native_fence(struct lima_ctx_mgr *mgr,
-					    u32 ctx, u32 pipe, u32 seq)
-{
-	struct lima_ctx *c;
-	struct dma_fence *ret;
-
-	if (pipe >= lima_pipe_num)
-		return ERR_PTR(-EINVAL);
-
-	c = lima_ctx_get(mgr, ctx);
-	if (!c)
-		return ERR_PTR(-ENOENT);
-
-	ret = lima_sched_context_get_fence(c->context + pipe, seq);
-
-	lima_ctx_put(c);
-	return ret;
+	xa_destroy(&mgr->handles);
+	mutex_destroy(&mgr->lock);
 }
diff --git a/drivers/gpu/drm/lima/lima_ctx.h b/drivers/gpu/drm/lima/lima_ctx.h
index 80e55e166..6154e5c9b 100644
--- a/drivers/gpu/drm/lima/lima_ctx.h
+++ b/drivers/gpu/drm/lima/lima_ctx.h
@@ -1,10 +1,10 @@
 /* SPDX-License-Identifier: GPL-2.0 OR MIT */
-/* Copyright 2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2018-2019 Qiang Yu <yuq825@gmail.com> */
 
 #ifndef __LIMA_CTX_H__
 #define __LIMA_CTX_H__
 
-#include <linux/idr.h>
+#include <linux/xarray.h>
 
 #include "lima_device.h"
 
@@ -16,8 +16,8 @@ struct lima_ctx {
 };
 
 struct lima_ctx_mgr {
-	spinlock_t lock;
-	struct idr handles;
+	struct mutex lock;
+	struct xarray handles;
 };
 
 int lima_ctx_create(struct lima_device *dev, struct lima_ctx_mgr *mgr, u32 *id);
@@ -27,7 +27,4 @@ void lima_ctx_put(struct lima_ctx *ctx);
 void lima_ctx_mgr_init(struct lima_ctx_mgr *mgr);
 void lima_ctx_mgr_fini(struct lima_ctx_mgr *mgr);
 
-struct dma_fence *lima_ctx_get_native_fence(struct lima_ctx_mgr *mgr,
-					    u32 ctx, u32 pipe, u32 seq);
-
 #endif
diff --git a/drivers/gpu/drm/lima/lima_device.c b/drivers/gpu/drm/lima/lima_device.c
index b88c84d79..570d0e93f 100644
--- a/drivers/gpu/drm/lima/lima_device.c
+++ b/drivers/gpu/drm/lima/lima_device.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0 OR MIT
-/* Copyright 2017-2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2017-2019 Qiang Yu <yuq825@gmail.com> */
 
 #include <linux/regulator/consumer.h>
 #include <linux/reset.h>
@@ -23,8 +23,8 @@ struct lima_ip_desc {
 	bool must_have[lima_gpu_num];
 	int offset[lima_gpu_num];
 
-	int (*init)(struct lima_ip *);
-	void (*fini)(struct lima_ip *);
+	int (*init)(struct lima_ip *ip);
+	void (*fini)(struct lima_ip *ip);
 };
 
 #define LIMA_IP_DESC(ipname, mst0, mst1, off0, off1, func, irq) \
@@ -100,9 +100,12 @@ static int lima_clk_init(struct lima_device *dev)
 	gpu_rate = clk_get_rate(dev->clk_gpu);
 	dev_info(dev->dev, "mod rate = %lu", gpu_rate);
 
-	if ((err = clk_prepare_enable(dev->clk_bus)))
+	err = clk_prepare_enable(dev->clk_bus);
+	if (err)
 		return err;
-	if ((err = clk_prepare_enable(dev->clk_gpu)))
+
+	err = clk_prepare_enable(dev->clk_gpu);
+	if (err)
 		goto error_out0;
 
 	dev->reset = devm_reset_control_get_optional(dev->dev, NULL);
@@ -110,7 +113,8 @@ static int lima_clk_init(struct lima_device *dev)
 		err = PTR_ERR(dev->reset);
 		goto error_out1;
 	} else if (dev->reset != NULL) {
-		if ((err = reset_control_deassert(dev->reset)))
+		err = reset_control_deassert(dev->reset);
+		if (err)
 			goto error_out1;
 	}
 
@@ -134,13 +138,14 @@ static void lima_clk_fini(struct lima_device *dev)
 static int lima_regulator_init(struct lima_device *dev)
 {
 	int ret;
+
 	dev->regulator = devm_regulator_get_optional(dev->dev, "mali");
 	if (IS_ERR(dev->regulator)) {
 		ret = PTR_ERR(dev->regulator);
 		dev->regulator = NULL;
 		if (ret == -ENODEV)
 			return 0;
-		dev_err(dev->dev, "failed to get regulator: %ld\n", PTR_ERR(dev->regulator));
+		dev_err(dev->dev, "failed to get regulator: %d\n", ret);
 		return ret;
 	}
 
@@ -204,14 +209,16 @@ static int lima_init_gp_pipe(struct lima_device *dev)
 	struct lima_sched_pipe *pipe = dev->pipe + lima_pipe_gp;
 	int err;
 
-	if ((err = lima_sched_pipe_init(pipe, "gp")))
+	err = lima_sched_pipe_init(pipe, "gp");
+	if (err)
 		return err;
 
 	pipe->l2_cache[pipe->num_l2_cache++] = dev->ip + lima_ip_l2_cache0;
 	pipe->mmu[pipe->num_mmu++] = dev->ip + lima_ip_gpmmu;
 	pipe->processor[pipe->num_processor++] = dev->ip + lima_ip_gp;
 
-	if ((err = lima_gp_pipe_init(dev))) {
+	err = lima_gp_pipe_init(dev);
+	if (err) {
 		lima_sched_pipe_fini(pipe);
 		return err;
 	}
@@ -232,7 +239,8 @@ static int lima_init_pp_pipe(struct lima_device *dev)
 	struct lima_sched_pipe *pipe = dev->pipe + lima_pipe_pp;
 	int err, i;
 
-	if ((err = lima_sched_pipe_init(pipe, "pp")))
+	err = lima_sched_pipe_init(pipe, "pp");
+	if (err)
 		return err;
 
 	for (i = 0; i < LIMA_SCHED_PIPE_MAX_PROCESSOR; i++) {
@@ -258,7 +266,8 @@ static int lima_init_pp_pipe(struct lima_device *dev)
 		pipe->bcast_mmu = dev->ip + lima_ip_ppmmu_bcast;
 	}
 
-	if ((err = lima_pp_pipe_init(dev))) {
+	err = lima_pp_pipe_init(dev);
+	if (err) {
 		lima_sched_pipe_fini(pipe);
 		return err;
 	}
@@ -287,19 +296,16 @@ int lima_device_init(struct lima_device *ldev)
 		return err;
 	}
 
-	if ((err = lima_regulator_init(ldev))) {
+	err = lima_regulator_init(ldev);
+	if (err) {
 		dev_err(ldev->dev, "regulator init fail %d\n", err);
 		goto err_out0;
 	}
 
-	err = lima_ttm_init(ldev);
-	if (err)
-		goto err_out1;
-
 	ldev->empty_vm = lima_vm_create(ldev);
 	if (!ldev->empty_vm) {
 		err = -ENOMEM;
-		goto err_out2;
+		goto err_out1;
 	}
 
 	ldev->va_start = 0;
@@ -310,49 +316,46 @@ int lima_device_init(struct lima_device *ldev)
 			&ldev->dlbu_dma, GFP_KERNEL);
 		if (!ldev->dlbu_cpu) {
 			err = -ENOMEM;
-			goto err_out3;
+			goto err_out2;
 		}
-	}
-	else
+	} else
 		ldev->va_end = LIMA_VA_RESERVE_END;
 
 	res = platform_get_resource(ldev->pdev, IORESOURCE_MEM, 0);
 	ldev->iomem = devm_ioremap_resource(ldev->dev, res);
 	if (IS_ERR(ldev->iomem)) {
 		dev_err(ldev->dev, "fail to ioremap iomem\n");
-	        err = PTR_ERR(ldev->iomem);
-		goto err_out4;
+		err = PTR_ERR(ldev->iomem);
+		goto err_out3;
 	}
 
 	for (i = 0; i < lima_ip_num; i++) {
 		err = lima_init_ip(ldev, i);
 		if (err)
-			goto err_out5;
+			goto err_out4;
 	}
 
 	err = lima_init_gp_pipe(ldev);
 	if (err)
-		goto err_out5;
+		goto err_out4;
 
 	err = lima_init_pp_pipe(ldev);
 	if (err)
-		goto err_out6;
+		goto err_out5;
 
 	return 0;
 
-err_out6:
-	lima_fini_gp_pipe(ldev);
 err_out5:
+	lima_fini_gp_pipe(ldev);
+err_out4:
 	while (--i >= 0)
 		lima_fini_ip(ldev, i);
-err_out4:
+err_out3:
 	if (ldev->dlbu_cpu)
 		dma_free_wc(ldev->dev, LIMA_PAGE_SIZE,
 			    ldev->dlbu_cpu, ldev->dlbu_dma);
-err_out3:
-	lima_vm_put(ldev->empty_vm);
 err_out2:
-	lima_ttm_fini(ldev);
+	lima_vm_put(ldev->empty_vm);
 err_out1:
 	lima_regulator_fini(ldev);
 err_out0:
@@ -376,8 +379,6 @@ void lima_device_fini(struct lima_device *ldev)
 
 	lima_vm_put(ldev->empty_vm);
 
-	lima_ttm_fini(ldev);
-
 	lima_regulator_fini(ldev);
 
 	lima_clk_fini(ldev);
diff --git a/drivers/gpu/drm/lima/lima_device.h b/drivers/gpu/drm/lima/lima_device.h
index d355a2c5c..31158d862 100644
--- a/drivers/gpu/drm/lima/lima_device.h
+++ b/drivers/gpu/drm/lima/lima_device.h
@@ -1,13 +1,13 @@
 /* SPDX-License-Identifier: GPL-2.0 OR MIT */
-/* Copyright 2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2018-2019 Qiang Yu <yuq825@gmail.com> */
 
 #ifndef __LIMA_DEVICE_H__
 #define __LIMA_DEVICE_H__
 
 #include <drm/drm_device.h>
+#include <linux/delay.h>
 
 #include "lima_sched.h"
-#include "lima_ttm.h"
 
 enum lima_gpu_id {
 	lima_gpu_mali400 = 0,
@@ -56,8 +56,6 @@ struct lima_ip {
 	int irq;
 
 	union {
-		/* pmu */
-		unsigned switch_delay;
 		/* gp/pp */
 		bool async_reset;
 		/* l2 cache */
@@ -77,6 +75,8 @@ struct lima_device {
 	struct platform_device *pdev;
 
 	enum lima_gpu_id id;
+	u32 gp_version;
+	u32 pp_version;
 	int num_pp;
 
 	void __iomem *iomem;
@@ -88,8 +88,6 @@ struct lima_device {
 	struct lima_ip ip[lima_ip_num];
 	struct lima_sched_pipe pipe[lima_pipe_num];
 
-	struct lima_mman mman;
-
 	struct lima_vm *empty_vm;
 	uint64_t va_start;
 	uint64_t va_end;
@@ -104,15 +102,30 @@ to_lima_dev(struct drm_device *dev)
 	return dev->dev_private;
 }
 
-static inline struct lima_device *
-ttm_to_lima_dev(struct ttm_bo_device *dev)
-{
-	return container_of(dev, struct lima_device, mman.bdev);
-}
-
 int lima_device_init(struct lima_device *ldev);
 void lima_device_fini(struct lima_device *ldev);
 
 const char *lima_ip_name(struct lima_ip *ip);
 
+typedef int (*lima_poll_func_t)(struct lima_ip *);
+
+static inline int lima_poll_timeout(struct lima_ip *ip, lima_poll_func_t func,
+				    int sleep_us, int timeout_us)
+{
+	ktime_t timeout = ktime_add_us(ktime_get(), timeout_us);
+
+	might_sleep_if(sleep_us);
+	while (1) {
+		if (func(ip))
+			return 0;
+
+		if (timeout_us && ktime_compare(ktime_get(), timeout) > 0)
+			return -ETIMEDOUT;
+
+		if (sleep_us)
+			usleep_range((sleep_us >> 2) + 1, sleep_us);
+	}
+	return 0;
+}
+
 #endif
diff --git a/drivers/gpu/drm/lima/lima_dlbu.c b/drivers/gpu/drm/lima/lima_dlbu.c
index 6697d4ddd..8399ceffb 100644
--- a/drivers/gpu/drm/lima/lima_dlbu.c
+++ b/drivers/gpu/drm/lima/lima_dlbu.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0 OR MIT
-/* Copyright 2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2018-2019 Qiang Yu <yuq825@gmail.com> */
 
 #include <linux/io.h>
 #include <linux/device.h>
@@ -9,8 +9,8 @@
 #include "lima_vm.h"
 #include "lima_regs.h"
 
-#define dlbu_write(reg, data) writel(data, ip->iomem + LIMA_DLBU_##reg)
-#define dlbu_read(reg) readl(ip->iomem + LIMA_DLBU_##reg)
+#define dlbu_write(reg, data) writel(data, ip->iomem + reg)
+#define dlbu_read(reg) readl(ip->iomem + reg)
 
 void lima_dlbu_enable(struct lima_device *dev, int num_pp)
 {
@@ -20,37 +20,39 @@ void lima_dlbu_enable(struct lima_device *dev, int num_pp)
 
 	for (i = 0; i < num_pp; i++) {
 		struct lima_ip *pp = pipe->processor[i];
+
 		mask |= 1 << (pp->id - lima_ip_pp0);
 	}
 
-	dlbu_write(PP_ENABLE_MASK, mask);
+	dlbu_write(LIMA_DLBU_PP_ENABLE_MASK, mask);
 }
 
 void lima_dlbu_disable(struct lima_device *dev)
 {
 	struct lima_ip *ip = dev->ip + lima_ip_dlbu;
-	dlbu_write(PP_ENABLE_MASK, 0);
+
+	dlbu_write(LIMA_DLBU_PP_ENABLE_MASK, 0);
 }
 
 void lima_dlbu_set_reg(struct lima_ip *ip, u32 *reg)
 {
-	dlbu_write(TLLIST_VBASEADDR, reg[0]);
-	dlbu_write(FB_DIM, reg[1]);
-	dlbu_write(TLLIST_CONF, reg[2]);
-	dlbu_write(START_TILE_POS, reg[3]);
+	dlbu_write(LIMA_DLBU_TLLIST_VBASEADDR, reg[0]);
+	dlbu_write(LIMA_DLBU_FB_DIM, reg[1]);
+	dlbu_write(LIMA_DLBU_TLLIST_CONF, reg[2]);
+	dlbu_write(LIMA_DLBU_START_TILE_POS, reg[3]);
 }
 
 int lima_dlbu_init(struct lima_ip *ip)
 {
 	struct lima_device *dev = ip->dev;
 
-	dlbu_write(MASTER_TLLIST_PHYS_ADDR, dev->dlbu_dma | 1);
-	dlbu_write(MASTER_TLLIST_VADDR, LIMA_VA_RESERVE_DLBU);
+	dlbu_write(LIMA_DLBU_MASTER_TLLIST_PHYS_ADDR, dev->dlbu_dma | 1);
+	dlbu_write(LIMA_DLBU_MASTER_TLLIST_VADDR, LIMA_VA_RESERVE_DLBU);
 
 	return 0;
 }
 
 void lima_dlbu_fini(struct lima_ip *ip)
 {
-	
+
 }
diff --git a/drivers/gpu/drm/lima/lima_dlbu.h b/drivers/gpu/drm/lima/lima_dlbu.h
index 60cba387c..16f877984 100644
--- a/drivers/gpu/drm/lima/lima_dlbu.h
+++ b/drivers/gpu/drm/lima/lima_dlbu.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0 OR MIT */
-/* Copyright 2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2018-2019 Qiang Yu <yuq825@gmail.com> */
 
 #ifndef __LIMA_DLBU_H__
 #define __LIMA_DLBU_H__
diff --git a/drivers/gpu/drm/lima/lima_drv.c b/drivers/gpu/drm/lima/lima_drv.c
index 536d0d442..f9a281a62 100644
--- a/drivers/gpu/drm/lima/lima_drv.c
+++ b/drivers/gpu/drm/lima/lima_drv.c
@@ -1,9 +1,12 @@
 // SPDX-License-Identifier: GPL-2.0 OR MIT
-/* Copyright 2017-2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2017-2019 Qiang Yu <yuq825@gmail.com> */
 
 #include <linux/module.h>
 #include <linux/of_platform.h>
-#include <linux/log2.h>
+#include <linux/uaccess.h>
+#include <linux/slab.h>
+#include <drm/drm_ioctl.h>
+#include <drm/drm_drv.h>
 #include <drm/drm_prime.h>
 #include <drm/lima_drm.h>
 
@@ -12,37 +15,50 @@
 #include "lima_gem_prime.h"
 #include "lima_vm.h"
 
-int lima_sched_timeout_ms = 0;
-int lima_sched_max_tasks = 32;
-int lima_max_mem = -1;
+int lima_sched_timeout_ms;
 
 MODULE_PARM_DESC(sched_timeout_ms, "task run timeout in ms (0 = no timeout (default))");
 module_param_named(sched_timeout_ms, lima_sched_timeout_ms, int, 0444);
 
-MODULE_PARM_DESC(sched_max_tasks, "max queued task num in a context (default 32)");
-module_param_named(sched_max_tasks, lima_sched_max_tasks, int, 0444);
-
-MODULE_PARM_DESC(max_mem, "Max memory size in MB can be used (<0 = auto)");
-module_param_named(max_mem, lima_max_mem, int, 0444);
-
-static int lima_ioctl_info(struct drm_device *dev, void *data, struct drm_file *file)
+static int lima_ioctl_get_param(struct drm_device *dev, void *data, struct drm_file *file)
 {
-	struct drm_lima_info *info = data;
+	struct drm_lima_get_param *args = data;
 	struct lima_device *ldev = to_lima_dev(dev);
 
-	switch (ldev->id) {
-	case lima_gpu_mali400:
-		info->gpu_id = LIMA_INFO_GPU_MALI400;
+	if (args->pad)
+		return -EINVAL;
+
+	switch (args->param) {
+	case DRM_LIMA_PARAM_GPU_ID:
+		switch (ldev->id) {
+		case lima_gpu_mali400:
+			args->value = DRM_LIMA_PARAM_GPU_ID_MALI400;
+			break;
+		case lima_gpu_mali450:
+			args->value = DRM_LIMA_PARAM_GPU_ID_MALI450;
+			break;
+		default:
+			args->value = DRM_LIMA_PARAM_GPU_ID_UNKNOWN;
+			break;
+		}
 		break;
-	case lima_gpu_mali450:
-		info->gpu_id = LIMA_INFO_GPU_MALI450;
+
+	case DRM_LIMA_PARAM_NUM_PP:
+		args->value = ldev->pipe[lima_pipe_pp].num_processor;
+		break;
+
+	case DRM_LIMA_PARAM_GP_VERSION:
+		args->value = ldev->gp_version;
 		break;
+
+	case DRM_LIMA_PARAM_PP_VERSION:
+		args->value = ldev->pp_version;
+		break;
+
 	default:
-		return -ENODEV;
+		return -EINVAL;
 	}
-	info->num_pp = ldev->pipe[lima_pipe_pp].num_processor;
-	info->va_start = ldev->va_start;
-	info->va_end = ldev->va_end;
+
 	return 0;
 }
 
@@ -50,6 +66,9 @@ static int lima_ioctl_gem_create(struct drm_device *dev, void *data, struct drm_
 {
 	struct drm_lima_gem_create *args = data;
 
+	if (args->pad)
+		return -EINVAL;
+
 	if (args->flags)
 		return -EINVAL;
 
@@ -63,51 +82,33 @@ static int lima_ioctl_gem_info(struct drm_device *dev, void *data, struct drm_fi
 {
 	struct drm_lima_gem_info *args = data;
 
-	return lima_gem_mmap_offset(file, args->handle, &args->offset);
-}
-
-static int lima_ioctl_gem_va(struct drm_device *dev, void *data, struct drm_file *file)
-{
-	struct drm_lima_gem_va *args = data;
-
-	switch (args->op) {
-	case LIMA_VA_OP_MAP:
-		return lima_gem_va_map(file, args->handle, args->flags, args->va);
-	case LIMA_VA_OP_UNMAP:
-		return lima_gem_va_unmap(file, args->handle, args->va);
-	default:
-		return -EINVAL;
-	}
+	return lima_gem_get_info(file, args->handle, &args->va, &args->offset);
 }
 
 static int lima_ioctl_gem_submit(struct drm_device *dev, void *data, struct drm_file *file)
 {
-	struct drm_lima_gem_submit_in *args = data;
+	struct drm_lima_gem_submit *args = data;
 	struct lima_device *ldev = to_lima_dev(dev);
 	struct lima_drm_priv *priv = file->driver_priv;
 	struct drm_lima_gem_submit_bo *bos;
-	struct ttm_validate_buffer *vbs;
-	union drm_lima_gem_submit_dep *deps = NULL;
 	struct lima_sched_pipe *pipe;
 	struct lima_sched_task *task;
 	struct lima_ctx *ctx;
 	struct lima_submit submit = {0};
-	int err = 0, size;
+	size_t size;
+	int err = 0;
 
 	if (args->pipe >= lima_pipe_num || args->nr_bos == 0)
 		return -EINVAL;
 
-	if (args->flags & ~(LIMA_SUBMIT_FLAG_EXPLICIT_FENCE |
-			    LIMA_SUBMIT_FLAG_SYNC_FD_OUT))
+	if (args->flags & ~(LIMA_SUBMIT_FLAG_EXPLICIT_FENCE))
 		return -EINVAL;
 
 	pipe = ldev->pipe + args->pipe;
 	if (args->frame_size != pipe->frame_size)
 		return -EINVAL;
 
-	size = args->nr_bos * (sizeof(*submit.bos) + sizeof(*submit.vbs)) +
-		args->nr_deps * sizeof(*submit.deps);
-	bos = kzalloc(size, GFP_KERNEL);
+	bos = kvcalloc(args->nr_bos, sizeof(*submit.bos) + sizeof(*submit.lbos), GFP_KERNEL);
 	if (!bos)
 		return -ENOMEM;
 
@@ -117,17 +118,6 @@ static int lima_ioctl_gem_submit(struct drm_device *dev, void *data, struct drm_
 		goto out0;
 	}
 
-	vbs = (void *)bos + size;
-
-	if (args->nr_deps) {
-		deps = (void *)vbs + args->nr_bos * sizeof(*submit.vbs);
-		size = args->nr_deps * sizeof(*submit.deps);
-		if (copy_from_user(deps, u64_to_user_ptr(args->deps), size)) {
-			err = -EFAULT;
-			goto out0;
-		}
-	}
-
 	task = kmem_cache_zalloc(pipe->task_slab, GFP_KERNEL);
 	if (!task) {
 		err = -ENOMEM;
@@ -152,70 +142,23 @@ static int lima_ioctl_gem_submit(struct drm_device *dev, void *data, struct drm_
 
 	submit.pipe = args->pipe;
 	submit.bos = bos;
-	submit.vbs = vbs;
+	submit.lbos = (void *)bos + size;
 	submit.nr_bos = args->nr_bos;
 	submit.task = task;
 	submit.ctx = ctx;
-	submit.deps = deps;
-	submit.nr_deps = args->nr_deps;
 	submit.flags = args->flags;
+	submit.in_sync[0] = args->in_sync[0];
+	submit.in_sync[1] = args->in_sync[1];
+	submit.out_sync = args->out_sync;
 
 	err = lima_gem_submit(file, &submit);
-	if (!err) {
-		struct drm_lima_gem_submit_out *out = data;
-		out->fence = submit.fence;
-		out->done = submit.done;
-		out->sync_fd = submit.sync_fd;
-	}
 
 	lima_ctx_put(ctx);
 out1:
 	if (err)
 		kmem_cache_free(pipe->task_slab, task);
 out0:
-	kfree(bos);
-	return err;
-}
-
-static int lima_wait_fence(struct dma_fence *fence, u64 timeout_ns)
-{
-	signed long ret;
-
-	if (!timeout_ns)
-		ret = dma_fence_is_signaled(fence) ? 0 : -EBUSY;
-	else {
-		unsigned long timeout = lima_timeout_to_jiffies(timeout_ns);
-
-		/* must use long for result check because in 64bit arch int
-		 * will overflow if timeout is too large and get <0 result
-		 */
-		ret = dma_fence_wait_timeout(fence, true, timeout);
-		if (ret == 0)
-			ret = timeout ? -ETIMEDOUT : -EBUSY;
-		else if (ret > 0)
-			ret = 0;
-	}
-
-	return ret;
-}
-
-static int lima_ioctl_wait_fence(struct drm_device *dev, void *data, struct drm_file *file)
-{
-	struct drm_lima_wait_fence *args = data;
-	struct lima_drm_priv *priv = file->driver_priv;
-	struct dma_fence *fence;
-	int err = 0;
-
-	fence = lima_ctx_get_native_fence(&priv->ctx_mgr, args->ctx,
-					  args->pipe, args->seq);
-	if (IS_ERR(fence))
-		return PTR_ERR(fence);
-
-	if (fence) {
-		err = lima_wait_fence(fence, args->timeout_ns);
-		dma_fence_put(fence);
-	}
-
+	kvfree(bos);
 	return err;
 }
 
@@ -223,36 +166,33 @@ static int lima_ioctl_gem_wait(struct drm_device *dev, void *data, struct drm_fi
 {
 	struct drm_lima_gem_wait *args = data;
 
-	if (!(args->op & (LIMA_GEM_WAIT_READ|LIMA_GEM_WAIT_WRITE)))
-	    return -EINVAL;
+	if (args->op & ~(LIMA_GEM_WAIT_READ|LIMA_GEM_WAIT_WRITE))
+		return -EINVAL;
 
 	return lima_gem_wait(file, args->handle, args->op, args->timeout_ns);
 }
 
-static int lima_ioctl_ctx(struct drm_device *dev, void *data, struct drm_file *file)
+static int lima_ioctl_ctx_create(struct drm_device *dev, void *data, struct drm_file *file)
 {
-	struct drm_lima_ctx *args = data;
+	struct drm_lima_ctx_create *args = data;
 	struct lima_drm_priv *priv = file->driver_priv;
 	struct lima_device *ldev = to_lima_dev(dev);
 
-	if (args->op == LIMA_CTX_OP_CREATE)
-		return lima_ctx_create(ldev, &priv->ctx_mgr, &args->id);
-	else if (args->op == LIMA_CTX_OP_FREE)
-		return lima_ctx_free(&priv->ctx_mgr, args->id);
+	if (args->_pad)
+		return -EINVAL;
 
-	return -EINVAL;
+	return lima_ctx_create(ldev, &priv->ctx_mgr, &args->id);
 }
 
-static int lima_ioctl_gem_mod(struct drm_device *dev, void *data, struct drm_file *file)
+static int lima_ioctl_ctx_free(struct drm_device *dev, void *data, struct drm_file *file)
 {
-	struct drm_lima_gem_mod *args = data;
+	struct drm_lima_ctx_create *args = data;
+	struct lima_drm_priv *priv = file->driver_priv;
 
-	if (args->op == LIMA_GEM_MOD_OP_GET)
-		return lima_gem_get_modifier(file, args->handle, &args->modifier);
-	else if (args->op == LIMA_GEM_MOD_OP_SET)
-		return lima_gem_set_modifier(file, args->handle, args->modifier);
+	if (args->_pad)
+		return -EINVAL;
 
-	return -EINVAL;
+	return lima_ctx_free(&priv->ctx_mgr, args->id);
 }
 
 static int lima_drm_driver_open(struct drm_device *dev, struct drm_file *file)
@@ -271,7 +211,7 @@ static int lima_drm_driver_open(struct drm_device *dev, struct drm_file *file)
 		goto err_out0;
 	}
 
-        lima_ctx_mgr_init(&priv->ctx_mgr);
+	lima_ctx_mgr_init(&priv->ctx_mgr);
 
 	file->driver_priv = priv;
 	return 0;
@@ -291,15 +231,13 @@ static void lima_drm_driver_postclose(struct drm_device *dev, struct drm_file *f
 }
 
 static const struct drm_ioctl_desc lima_drm_driver_ioctls[] = {
-	DRM_IOCTL_DEF_DRV(LIMA_INFO, lima_ioctl_info, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(LIMA_GET_PARAM, lima_ioctl_get_param, DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(LIMA_GEM_CREATE, lima_ioctl_gem_create, DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(LIMA_GEM_INFO, lima_ioctl_gem_info, DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(LIMA_GEM_VA, lima_ioctl_gem_va, DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(LIMA_GEM_SUBMIT, lima_ioctl_gem_submit, DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(LIMA_WAIT_FENCE, lima_ioctl_wait_fence, DRM_AUTH|DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF_DRV(LIMA_GEM_WAIT, lima_ioctl_gem_wait, DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(LIMA_CTX, lima_ioctl_ctx, DRM_AUTH|DRM_RENDER_ALLOW),
-	DRM_IOCTL_DEF_DRV(LIMA_GEM_MOD, lima_ioctl_gem_mod, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(LIMA_CTX_CREATE, lima_ioctl_ctx_create, DRM_AUTH|DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF_DRV(LIMA_CTX_FREE, lima_ioctl_ctx_free, DRM_AUTH|DRM_RENDER_ALLOW),
 };
 
 static const struct file_operations lima_drm_driver_fops = {
@@ -314,7 +252,7 @@ static const struct file_operations lima_drm_driver_fops = {
 };
 
 static struct drm_driver lima_drm_driver = {
-	.driver_features    = DRIVER_RENDER | DRIVER_GEM | DRIVER_PRIME,
+	.driver_features    = DRIVER_RENDER | DRIVER_GEM | DRIVER_PRIME | DRIVER_SYNCOBJ,
 	.open               = lima_drm_driver_open,
 	.postclose          = lima_drm_driver_postclose,
 	.ioctls             = lima_drm_driver_ioctls,
@@ -323,20 +261,19 @@ static struct drm_driver lima_drm_driver = {
 	.gem_free_object_unlocked = lima_gem_free_object,
 	.gem_open_object    = lima_gem_object_open,
 	.gem_close_object   = lima_gem_object_close,
+	.gem_vm_ops         = &lima_gem_vm_ops,
 	.name               = "lima",
 	.desc               = "lima DRM",
-	.date               = "20170325",
+	.date               = "20190217",
 	.major              = 1,
 	.minor              = 0,
 	.patchlevel         = 0,
 
 	.prime_fd_to_handle = drm_gem_prime_fd_to_handle,
-	.gem_prime_import   = drm_gem_prime_import,
 	.gem_prime_import_sg_table = lima_gem_prime_import_sg_table,
 	.prime_handle_to_fd = drm_gem_prime_handle_to_fd,
-	.gem_prime_export   = drm_gem_prime_export,
-	.gem_prime_res_obj  = lima_gem_prime_res_obj,
 	.gem_prime_get_sg_table = lima_gem_prime_get_sg_table,
+	.gem_prime_mmap = lima_gem_prime_mmap,
 };
 
 static int lima_pdev_probe(struct platform_device *pdev)
@@ -345,9 +282,15 @@ static int lima_pdev_probe(struct platform_device *pdev)
 	struct drm_device *ddev;
 	int err;
 
+	err = lima_sched_slab_init();
+	if (err)
+		return err;
+
 	ldev = devm_kzalloc(&pdev->dev, sizeof(*ldev), GFP_KERNEL);
-	if (!ldev)
-		return -ENOMEM;
+	if (!ldev) {
+		err = -ENOMEM;
+		goto err_out0;
+	}
 
 	ldev->pdev = pdev;
 	ldev->dev = &pdev->dev;
@@ -366,7 +309,7 @@ static int lima_pdev_probe(struct platform_device *pdev)
 	err = lima_device_init(ldev);
 	if (err) {
 		dev_err(&pdev->dev, "Fatal error during GPU init\n");
-		goto err_out0;
+		goto err_out1;
 	}
 
 	/*
@@ -375,14 +318,16 @@ static int lima_pdev_probe(struct platform_device *pdev)
 	 */
 	err = drm_dev_register(ddev, 0);
 	if (err < 0)
-		goto err_out1;
+		goto err_out2;
 
 	return 0;
 
-err_out1:
+err_out2:
 	lima_device_fini(ldev);
+err_out1:
+	drm_dev_put(ddev);
 err_out0:
-	drm_dev_unref(ddev);
+	lima_sched_slab_fini();
 	return err;
 }
 
@@ -393,7 +338,8 @@ static int lima_pdev_remove(struct platform_device *pdev)
 
 	drm_dev_unregister(ddev);
 	lima_device_fini(ldev);
-	drm_dev_unref(ddev);
+	drm_dev_put(ddev);
+	lima_sched_slab_fini();
 	return 0;
 }
 
@@ -413,38 +359,15 @@ static struct platform_driver lima_platform_driver = {
 	},
 };
 
-static void lima_check_module_param(void)
-{
-	if (lima_sched_max_tasks < 4)
-		lima_sched_max_tasks = 4;
-	else
-		lima_sched_max_tasks = roundup_pow_of_two(lima_sched_max_tasks);
-
-	if (lima_max_mem < 32)
-		lima_max_mem = -1;
-}
-
 static int __init lima_init(void)
 {
-	int ret;
-
-	lima_check_module_param();
-	ret = lima_sched_slab_init();
-	if (ret)
-		return ret;
-
-	ret = platform_driver_register(&lima_platform_driver);
-	if (ret)
-		lima_sched_slab_fini();
-
-	return ret;
+	return platform_driver_register(&lima_platform_driver);
 }
 module_init(lima_init);
 
 static void __exit lima_exit(void)
 {
 	platform_driver_unregister(&lima_platform_driver);
-	lima_sched_slab_fini();
 }
 module_exit(lima_exit);
 
diff --git a/drivers/gpu/drm/lima/lima_drv.h b/drivers/gpu/drm/lima/lima_drv.h
index 455bf44ae..69c734471 100644
--- a/drivers/gpu/drm/lima/lima_drv.h
+++ b/drivers/gpu/drm/lima/lima_drv.h
@@ -1,17 +1,14 @@
 /* SPDX-License-Identifier: GPL-2.0 OR MIT */
-/* Copyright 2017-2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2017-2019 Qiang Yu <yuq825@gmail.com> */
 
 #ifndef __LIMA_DRV_H__
 #define __LIMA_DRV_H__
 
-#include <drm/drmP.h>
-#include <drm/ttm/ttm_execbuf_util.h>
+#include <drm/drm_file.h>
 
 #include "lima_ctx.h"
 
 extern int lima_sched_timeout_ms;
-extern int lima_sched_max_tasks;
-extern int lima_max_mem;
 
 struct lima_vm;
 struct lima_bo;
@@ -19,8 +16,6 @@ struct lima_sched_task;
 
 struct drm_lima_gem_submit_bo;
 
-#define DRM_FILE_PAGE_OFFSET (0x100000000ULL >> PAGE_SHIFT)
-
 struct lima_drm_priv {
 	struct lima_vm *vm;
 	struct lima_ctx_mgr ctx_mgr;
@@ -32,22 +27,13 @@ struct lima_submit {
 	u32 flags;
 
 	struct drm_lima_gem_submit_bo *bos;
-	struct ttm_validate_buffer *vbs;
+	struct lima_bo **lbos;
 	u32 nr_bos;
 
-	struct ttm_validate_buffer vm_pd_vb;
-	struct ww_acquire_ctx ticket;
-	struct list_head duplicates;
-	struct list_head validated;
-
-	union drm_lima_gem_submit_dep *deps;
-	u32 nr_deps;
+	u32 in_sync[2];
+	u32 out_sync;
 
 	struct lima_sched_task *task;
-
-	uint32_t fence;
-	uint32_t done;
-	int sync_fd;
 };
 
 static inline struct lima_drm_priv *
diff --git a/drivers/gpu/drm/lima/lima_gem.c b/drivers/gpu/drm/lima/lima_gem.c
index 02bf76113..2d3cf96f6 100644
--- a/drivers/gpu/drm/lima/lima_gem.c
+++ b/drivers/gpu/drm/lima/lima_gem.c
@@ -1,15 +1,18 @@
 // SPDX-License-Identifier: GPL-2.0 OR MIT
-/* Copyright 2017-2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2017-2019 Qiang Yu <yuq825@gmail.com> */
 
-#include <drm/drmP.h>
-#include <linux/dma-mapping.h>
-#include <linux/pagemap.h>
 #include <linux/sync_file.h>
+#include <linux/pfn_t.h>
+
+#include <drm/drm_file.h>
+#include <drm/drm_syncobj.h>
+#include <drm/drm_utils.h>
 
 #include <drm/lima_drm.h>
 
 #include "lima_drv.h"
 #include "lima_gem.h"
+#include "lima_gem_prime.h"
 #include "lima_vm.h"
 #include "lima_object.h"
 
@@ -20,7 +23,7 @@ int lima_gem_create_handle(struct drm_device *dev, struct drm_file *file,
 	struct lima_bo *bo;
 	struct lima_device *ldev = to_lima_dev(dev);
 
-	bo = lima_bo_create(ldev, size, flags, ttm_bo_type_device, NULL, NULL);
+	bo = lima_bo_create(ldev, size, flags, NULL, NULL);
 	if (IS_ERR(bo))
 		return PTR_ERR(bo);
 
@@ -39,7 +42,7 @@ void lima_gem_free_object(struct drm_gem_object *obj)
 	if (!list_empty(&bo->va))
 		dev_err(obj->dev->dev, "lima gem free bo still has va\n");
 
-	lima_bo_unref(bo);
+	lima_bo_destroy(bo);
 }
 
 int lima_gem_object_open(struct drm_gem_object *obj, struct drm_file *file)
@@ -47,170 +50,83 @@ int lima_gem_object_open(struct drm_gem_object *obj, struct drm_file *file)
 	struct lima_bo *bo = to_lima_bo(obj);
 	struct lima_drm_priv *priv = to_lima_drm_priv(file);
 	struct lima_vm *vm = priv->vm;
-	int err;
-
-	err = lima_bo_reserve(bo, true);
-	if (err)
-		return err;
-
-	err = lima_vm_bo_add(vm, bo);
 
-	lima_bo_unreserve(bo);
-	return err;
+	return lima_vm_bo_add(vm, bo, true);
 }
 
 void lima_gem_object_close(struct drm_gem_object *obj, struct drm_file *file)
 {
 	struct lima_bo *bo = to_lima_bo(obj);
-	struct lima_device *dev = to_lima_dev(obj->dev);
 	struct lima_drm_priv *priv = to_lima_drm_priv(file);
 	struct lima_vm *vm = priv->vm;
 
-	LIST_HEAD(list);
-	struct ttm_validate_buffer tv_bo, tv_pd;
-	struct ww_acquire_ctx ticket;
-	int r;
-
-	tv_bo.bo = &bo->tbo;
-	tv_bo.shared = true;
-	list_add(&tv_bo.head, &list);
-
-	tv_pd.bo = &vm->pd->tbo;
-	tv_pd.shared = true;
-	list_add(&tv_pd.head, &list);
-
-	r = ttm_eu_reserve_buffers(&ticket, &list, false, NULL);
-	if (r) {
-		dev_err(dev->dev, "leeking bo va because we "
-			"fail to reserve bo (%d)\n", r);
-		return;
-	}
-
 	lima_vm_bo_del(vm, bo);
-
-	ttm_eu_backoff_reservation(&ticket, &list);
 }
 
-int lima_gem_mmap_offset(struct drm_file *file, u32 handle, u64 *offset)
+int lima_gem_get_info(struct drm_file *file, u32 handle, u32 *va, u64 *offset)
 {
 	struct drm_gem_object *obj;
 	struct lima_bo *bo;
-
-	obj = drm_gem_object_lookup(file, handle);
-	if (!obj)
-		return -ENOENT;
-
-	bo = to_lima_bo(obj);
-	*offset = drm_vma_node_offset_addr(&bo->tbo.vma_node);
-
-	drm_gem_object_put_unlocked(obj);
-	return 0;
-}
-
-int lima_gem_mmap(struct file *filp, struct vm_area_struct *vma)
-{
-	struct drm_file *file_priv;
-	struct lima_device *dev;
-
-	if (unlikely(vma->vm_pgoff < DRM_FILE_PAGE_OFFSET))
-		return -EINVAL;
-
-	file_priv = filp->private_data;
-	dev = file_priv->minor->dev->dev_private;
-	if (dev == NULL)
-		return -EINVAL;
-
-	return ttm_bo_mmap(filp, vma, &dev->mman.bdev);
-}
-
-int lima_gem_va_map(struct drm_file *file, u32 handle, u32 flags, u32 va)
-{
 	struct lima_drm_priv *priv = to_lima_drm_priv(file);
 	struct lima_vm *vm = priv->vm;
-	struct drm_gem_object *obj;
-	struct lima_bo *bo;
-	struct lima_device *dev;
 	int err;
 
-	LIST_HEAD(list);
-	struct ttm_validate_buffer tv_bo, tv_pd;
-	struct ww_acquire_ctx ticket;
-
-	if (!PAGE_ALIGNED(va))
-		return -EINVAL;
-
 	obj = drm_gem_object_lookup(file, handle);
 	if (!obj)
 		return -ENOENT;
 
 	bo = to_lima_bo(obj);
-	dev = to_lima_dev(obj->dev);
-
-	/* carefully handle overflow when calculate range */
-	if (va < dev->va_start || dev->va_end - obj->size < va) {
-		err = -EINVAL;
-		goto out;
-	}
 
-	tv_bo.bo = &bo->tbo;
-	tv_bo.shared = true;
-	list_add(&tv_bo.head, &list);
+	*va = lima_vm_get_va(vm, bo);
 
-	tv_pd.bo = &vm->pd->tbo;
-	tv_pd.shared = true;
-	list_add(&tv_pd.head, &list);
+	err = drm_gem_create_mmap_offset(obj);
+	if (!err)
+		*offset = drm_vma_node_offset_addr(&obj->vma_node);
 
-	err = ttm_eu_reserve_buffers(&ticket, &list, false, NULL);
-	if (err)
-		goto out;
-
-	err = lima_vm_bo_map(vm, bo, va);
-
-	ttm_eu_backoff_reservation(&ticket, &list);
-out:
 	drm_gem_object_put_unlocked(obj);
 	return err;
 }
 
-int lima_gem_va_unmap(struct drm_file *file, u32 handle, u32 va)
+static vm_fault_t lima_gem_fault(struct vm_fault *vmf)
 {
-	struct lima_drm_priv *priv = to_lima_drm_priv(file);
-	struct lima_vm *vm = priv->vm;
-	struct drm_gem_object *obj;
-	struct lima_bo *bo;
-	int err;
-
-	LIST_HEAD(list);
-	struct ttm_validate_buffer tv_bo, tv_pd;
-	struct ww_acquire_ctx ticket;
+	struct vm_area_struct *vma = vmf->vma;
+	struct drm_gem_object *obj = vma->vm_private_data;
+	struct lima_bo *bo = to_lima_bo(obj);
+	pfn_t pfn;
+	pgoff_t pgoff;
 
-	if (!PAGE_ALIGNED(va))
-		return -EINVAL;
+	/* We don't use vmf->pgoff since that has the fake offset: */
+	pgoff = (vmf->address - vma->vm_start) >> PAGE_SHIFT;
+	pfn = __pfn_to_pfn_t(page_to_pfn(bo->pages[pgoff]), PFN_DEV);
 
-	obj = drm_gem_object_lookup(file, handle);
-	if (!obj)
-		return -ENOENT;
+	return vmf_insert_mixed(vma, vmf->address, pfn);
+}
 
-	bo = to_lima_bo(obj);
+const struct vm_operations_struct lima_gem_vm_ops = {
+	.fault = lima_gem_fault,
+	.open = drm_gem_vm_open,
+	.close = drm_gem_vm_close,
+};
 
-	tv_bo.bo = &bo->tbo;
-	tv_bo.shared = true;
-	list_add(&tv_bo.head, &list);
+void lima_set_vma_flags(struct vm_area_struct *vma)
+{
+	pgprot_t prot = vm_get_page_prot(vma->vm_flags);
 
-	tv_pd.bo = &vm->pd->tbo;
-	tv_pd.shared = true;
-	list_add(&tv_pd.head, &list);
+	vma->vm_flags |= VM_MIXEDMAP;
+	vma->vm_flags &= ~VM_PFNMAP;
+	vma->vm_page_prot = pgprot_writecombine(prot);
+}
 
-	err = ttm_eu_reserve_buffers(&ticket, &list, false, NULL);
-	if (err)
-		goto out;
+int lima_gem_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	int ret;
 
-	err = lima_vm_bo_unmap(vm, bo, va);
+	ret = drm_gem_mmap(filp, vma);
+	if (ret)
+		return ret;
 
-	ttm_eu_backoff_reservation(&ticket, &list);
-out:
-	drm_gem_object_put_unlocked(obj);
-	return err;
+	lima_set_vma_flags(vma);
+	return 0;
 }
 
 static int lima_gem_sync_bo(struct lima_sched_task *task, struct lima_bo *bo,
@@ -219,7 +135,7 @@ static int lima_gem_sync_bo(struct lima_sched_task *task, struct lima_bo *bo,
 	int err = 0;
 
 	if (!write) {
-		err = reservation_object_reserve_shared(bo->tbo.resv);
+		err = reservation_object_reserve_shared(bo->gem.resv, 1);
 		if (err)
 			return err;
 	}
@@ -235,7 +151,7 @@ static int lima_gem_sync_bo(struct lima_sched_task *task, struct lima_bo *bo,
 		int i;
 
 		err = reservation_object_get_fences_rcu(
-			bo->tbo.resv, NULL, &nr_fences, &fences);
+			bo->gem.resv, NULL, &nr_fences, &fences);
 		if (err || !nr_fences)
 			return err;
 
@@ -250,10 +166,10 @@ static int lima_gem_sync_bo(struct lima_sched_task *task, struct lima_bo *bo,
 			dma_fence_put(fences[i]);
 
 		kfree(fences);
-	}
-	else {
+	} else {
 		struct dma_fence *fence;
-		fence = reservation_object_get_excl_rcu(bo->tbo.resv);
+
+		fence = reservation_object_get_excl_rcu(bo->gem.resv);
 		if (fence) {
 			err = lima_sched_task_add_dep(task, fence);
 			if (err)
@@ -264,215 +180,202 @@ static int lima_gem_sync_bo(struct lima_sched_task *task, struct lima_bo *bo,
 	return err;
 }
 
-static int lima_gem_add_deps(struct lima_ctx_mgr *mgr, struct lima_submit *submit)
+static int lima_gem_lock_bos(struct lima_bo **bos, u32 nr_bos,
+			     struct ww_acquire_ctx *ctx)
 {
-	int i, err = 0;
+	int i, ret = 0, contended, slow_locked = -1;
 
-	for (i = 0; i < submit->nr_deps; i++) {
-		union drm_lima_gem_submit_dep *dep = submit->deps + i;
-		struct dma_fence *fence;
+	ww_acquire_init(ctx, &reservation_ww_class);
 
-		if (dep->type == LIMA_SUBMIT_DEP_FENCE) {
-			fence = lima_ctx_get_native_fence(
-				mgr, dep->fence.ctx, dep->fence.pipe,
-				dep->fence.seq);
-			if (IS_ERR(fence)) {
-				err = PTR_ERR(fence);
-				break;
-			}
+retry:
+	for (i = 0; i < nr_bos; i++) {
+		if (i == slow_locked) {
+			slow_locked = -1;
+			continue;
 		}
-		else if (dep->type == LIMA_SUBMIT_DEP_SYNC_FD) {
-			fence = sync_file_get_fence(dep->sync_fd.fd);
-			if (!fence) {
-				err = -EINVAL;
-				break;
-			}
-		}
-		else {
-			err = -EINVAL;
-			break;
+
+		ret = ww_mutex_lock_interruptible(&bos[i]->gem.resv->lock, ctx);
+		if (ret < 0) {
+			contended = i;
+			goto err;
 		}
+	}
 
-		if (fence) {
-			err = lima_sched_task_add_dep(submit->task, fence);
-			if (err) {
-				dma_fence_put(fence);
-				break;
-			}
+	ww_acquire_done(ctx);
+	return 0;
+
+err:
+	for (i--; i >= 0; i--)
+		ww_mutex_unlock(&bos[i]->gem.resv->lock);
+
+	if (slow_locked >= 0)
+		ww_mutex_unlock(&bos[slow_locked]->gem.resv->lock);
+
+	if (ret == -EDEADLK) {
+		/* we lost out in a seqno race, lock and retry.. */
+		ret = ww_mutex_lock_slow_interruptible(
+			&bos[contended]->gem.resv->lock, ctx);
+		if (!ret) {
+			slow_locked = contended;
+			goto retry;
 		}
 	}
+	ww_acquire_fini(ctx);
 
-	return err;
+	return ret;
+}
+
+static void lima_gem_unlock_bos(struct lima_bo **bos, u32 nr_bos,
+				struct ww_acquire_ctx *ctx)
+{
+	int i;
+
+	for (i = 0; i < nr_bos; i++)
+		ww_mutex_unlock(&bos[i]->gem.resv->lock);
+	ww_acquire_fini(ctx);
 }
 
-static int lima_gem_get_sync_fd(struct dma_fence *fence)
+static int lima_gem_add_deps(struct drm_file *file, struct lima_submit *submit)
 {
-	struct sync_file *sync_file;
-	int fd;
+	int i, err;
+
+	for (i = 0; i < ARRAY_SIZE(submit->in_sync); i++) {
+		struct dma_fence *fence = NULL;
 
-	fd = get_unused_fd_flags(O_CLOEXEC);
-	if (fd < 0)
-		return fd;
+		if (!submit->in_sync[i])
+			continue;
 
-	sync_file = sync_file_create(fence);
-	if (!sync_file) {
-		put_unused_fd(fd);
-		return -ENOMEM;
+		err = drm_syncobj_find_fence(file, submit->in_sync[i],
+					     0, 0, &fence);
+		if (err)
+			return err;
+
+		err = lima_sched_task_add_dep(submit->task, fence);
+		if (err) {
+			dma_fence_put(fence);
+			return err;
+		}
 	}
 
-	fd_install(fd, sync_file->file);
-	return fd;
+	return 0;
 }
 
 int lima_gem_submit(struct drm_file *file, struct lima_submit *submit)
 {
 	int i, err = 0;
+	struct ww_acquire_ctx ctx;
 	struct lima_drm_priv *priv = to_lima_drm_priv(file);
 	struct lima_vm *vm = priv->vm;
-
-	INIT_LIST_HEAD(&submit->validated);
-	INIT_LIST_HEAD(&submit->duplicates);
+	struct drm_syncobj *out_sync = NULL;
+	struct dma_fence *fence;
+	struct lima_bo **bos = submit->lbos;
+
+	if (submit->out_sync) {
+		out_sync = drm_syncobj_find(file, submit->out_sync);
+		if (!out_sync)
+			return -ENOENT;
+	}
 
 	for (i = 0; i < submit->nr_bos; i++) {
 		struct drm_gem_object *obj;
-		struct drm_lima_gem_submit_bo *bo = submit->bos + i;
-		struct ttm_validate_buffer *vb = submit->vbs + i;
+		struct lima_bo *bo;
 
-		obj = drm_gem_object_lookup(file, bo->handle);
+		obj = drm_gem_object_lookup(file, submit->bos[i].handle);
 		if (!obj) {
 			err = -ENOENT;
-			goto out0;
+			goto err_out0;
 		}
 
-		vb->bo = &to_lima_bo(obj)->tbo;
-		vb->shared = !(bo->flags & LIMA_SUBMIT_BO_WRITE);
-		list_add_tail(&vb->head, &submit->validated);
-	}
+		bo = to_lima_bo(obj);
 
-	submit->vm_pd_vb.bo = &vm->pd->tbo;
-	submit->vm_pd_vb.shared = true;
-	list_add(&submit->vm_pd_vb.head, &submit->validated);
+		/* increase refcnt of gpu va map to prevent unmapped when executing,
+		 * will be decreased when task done
+		 */
+		err = lima_vm_bo_add(vm, bo, false);
+		if (err) {
+			drm_gem_object_put_unlocked(obj);
+			goto err_out0;
+		}
 
-	err = ttm_eu_reserve_buffers(&submit->ticket, &submit->validated,
-				     true, &submit->duplicates);
+		bos[i] = bo;
+	}
+
+	err = lima_gem_lock_bos(bos, submit->nr_bos, &ctx);
 	if (err)
-		goto out0;
+		goto err_out0;
 
 	err = lima_sched_task_init(
-		submit->task, submit->ctx->context + submit->pipe, vm);
+		submit->task, submit->ctx->context + submit->pipe,
+		bos, submit->nr_bos, vm);
 	if (err)
-		goto out1;
+		goto err_out1;
 
-	err = lima_gem_add_deps(&priv->ctx_mgr, submit);
+	err = lima_gem_add_deps(file, submit);
 	if (err)
-		goto out2;
+		goto err_out2;
 
 	for (i = 0; i < submit->nr_bos; i++) {
-		struct ttm_validate_buffer *vb = submit->vbs + i;
-		struct lima_bo *bo = ttm_to_lima_bo(vb->bo);
 		err = lima_gem_sync_bo(
-			submit->task, bo, !vb->shared,
+			submit->task, bos[i],
+			submit->bos[i].flags & LIMA_SUBMIT_BO_WRITE,
 			submit->flags & LIMA_SUBMIT_FLAG_EXPLICIT_FENCE);
 		if (err)
-			goto out2;
+			goto err_out2;
 	}
 
-	if (submit->flags & LIMA_SUBMIT_FLAG_SYNC_FD_OUT) {
-		int fd = lima_gem_get_sync_fd(
-			&submit->task->base.s_fence->finished);
-		if (fd < 0) {
-			err = fd;
-			goto out2;
-		}
-		submit->sync_fd = fd;
+	fence = lima_sched_context_queue_task(
+		submit->ctx->context + submit->pipe, submit->task);
+
+	for (i = 0; i < submit->nr_bos; i++) {
+		if (submit->bos[i].flags & LIMA_SUBMIT_BO_WRITE)
+			reservation_object_add_excl_fence(bos[i]->gem.resv, fence);
+		else
+			reservation_object_add_shared_fence(bos[i]->gem.resv, fence);
 	}
 
-	submit->fence = lima_sched_context_queue_task(
-		submit->ctx->context + submit->pipe, submit->task,
-		&submit->done);
+	lima_gem_unlock_bos(bos, submit->nr_bos, &ctx);
 
-	ttm_eu_fence_buffer_objects(&submit->ticket, &submit->validated,
-				    &submit->task->base.s_fence->finished);
+	for (i = 0; i < submit->nr_bos; i++)
+		drm_gem_object_put_unlocked(&bos[i]->gem);
 
-out2:
-	if (err)
-		lima_sched_task_fini(submit->task);
-out1:
-        if (err)
-		ttm_eu_backoff_reservation(&submit->ticket, &submit->validated);
-out0:
+	if (out_sync) {
+		drm_syncobj_replace_fence(out_sync, fence);
+		drm_syncobj_put(out_sync);
+	}
+
+	dma_fence_put(fence);
+
+	return 0;
+
+err_out2:
+	lima_sched_task_fini(submit->task);
+err_out1:
+	lima_gem_unlock_bos(bos, submit->nr_bos, &ctx);
+err_out0:
 	for (i = 0; i < submit->nr_bos; i++) {
-		struct ttm_validate_buffer *vb = submit->vbs + i;
-		if (!vb->bo)
+		if (!bos[i])
 			break;
-		drm_gem_object_put_unlocked(&ttm_to_lima_bo(vb->bo)->gem);
+		lima_vm_bo_del(vm, bos[i]);
+		drm_gem_object_put_unlocked(&bos[i]->gem);
 	}
+	if (out_sync)
+		drm_syncobj_put(out_sync);
 	return err;
 }
 
-int lima_gem_wait(struct drm_file *file, u32 handle, u32 op, u64 timeout_ns)
+int lima_gem_wait(struct drm_file *file, u32 handle, u32 op, s64 timeout_ns)
 {
 	bool write = op & LIMA_GEM_WAIT_WRITE;
-	struct drm_gem_object *obj;
-	struct lima_bo *bo;
-	signed long ret;
-	unsigned long timeout;
-
-	obj = drm_gem_object_lookup(file, handle);
-	if (!obj)
-		return -ENOENT;
-
-	bo = to_lima_bo(obj);
+	long ret, timeout;
 
-	timeout = timeout_ns ? lima_timeout_to_jiffies(timeout_ns) : 0;
+	if (!op)
+		return 0;
 
-	ret = lima_bo_reserve(bo, true);
-	if (ret)
-		goto out;
+	timeout = drm_timeout_abs_to_jiffies(timeout_ns);
 
-	/* must use long for result check because in 64bit arch int
-	 * will overflow if timeout is too large and get <0 result
-	 */
-	ret = reservation_object_wait_timeout_rcu(bo->tbo.resv, write, true, timeout);
+	ret = drm_gem_reservation_object_wait(file, handle, write, timeout);
 	if (ret == 0)
 		ret = timeout ? -ETIMEDOUT : -EBUSY;
-	else if (ret > 0)
-		ret = 0;
 
-	lima_bo_unreserve(bo);
-out:
-	drm_gem_object_put_unlocked(obj);
 	return ret;
 }
-
-int lima_gem_get_modifier(struct drm_file *file, u32 handle, u64 *modifier)
-{
-	struct drm_gem_object *obj;
-	struct lima_bo *bo;
-
-	obj = drm_gem_object_lookup(file, handle);
-	if (!obj)
-		return -ENOENT;
-
-	bo = to_lima_bo(obj);
-	*modifier = bo->modifier;
-
-	drm_gem_object_put_unlocked(obj);
-	return 0;
-}
-
-int lima_gem_set_modifier(struct drm_file *file, u32 handle, u64 modifier)
-{
-	struct drm_gem_object *obj;
-	struct lima_bo *bo;
-
-	obj = drm_gem_object_lookup(file, handle);
-	if (!obj)
-		return -ENOENT;
-
-	bo = to_lima_bo(obj);
-	bo->modifier = modifier;
-
-	drm_gem_object_put_unlocked(obj);
-	return 0;
-}
diff --git a/drivers/gpu/drm/lima/lima_gem.h b/drivers/gpu/drm/lima/lima_gem.h
index da6968fab..556111a01 100644
--- a/drivers/gpu/drm/lima/lima_gem.h
+++ b/drivers/gpu/drm/lima/lima_gem.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0 OR MIT */
-/* Copyright 2017-2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2017-2019 Qiang Yu <yuq825@gmail.com> */
 
 #ifndef __LIMA_GEM_H__
 #define __LIMA_GEM_H__
@@ -7,19 +7,19 @@
 struct lima_bo;
 struct lima_submit;
 
+extern const struct vm_operations_struct lima_gem_vm_ops;
+
 struct lima_bo *lima_gem_create_bo(struct drm_device *dev, u32 size, u32 flags);
 int lima_gem_create_handle(struct drm_device *dev, struct drm_file *file,
 			   u32 size, u32 flags, u32 *handle);
 void lima_gem_free_object(struct drm_gem_object *obj);
 int lima_gem_object_open(struct drm_gem_object *obj, struct drm_file *file);
 void lima_gem_object_close(struct drm_gem_object *obj, struct drm_file *file);
-int lima_gem_mmap_offset(struct drm_file *file, u32 handle, u64 *offset);
+int lima_gem_get_info(struct drm_file *file, u32 handle, u32 *va, u64 *offset);
 int lima_gem_mmap(struct file *filp, struct vm_area_struct *vma);
-int lima_gem_va_map(struct drm_file *file, u32 handle, u32 flags, u32 va);
-int lima_gem_va_unmap(struct drm_file *file, u32 handle, u32 va);
 int lima_gem_submit(struct drm_file *file, struct lima_submit *submit);
-int lima_gem_wait(struct drm_file *file, u32 handle, u32 op, u64 timeout_ns);
-int lima_gem_get_modifier(struct drm_file *file, u32 handle, u64 *modifier);
-int lima_gem_set_modifier(struct drm_file *file, u32 handle, u64 modifier);
+int lima_gem_wait(struct drm_file *file, u32 handle, u32 op, s64 timeout_ns);
+
+void lima_set_vma_flags(struct vm_area_struct *vma);
 
 #endif
diff --git a/drivers/gpu/drm/lima/lima_gem_prime.c b/drivers/gpu/drm/lima/lima_gem_prime.c
index 0e0350ca7..9c6d9f1db 100644
--- a/drivers/gpu/drm/lima/lima_gem_prime.c
+++ b/drivers/gpu/drm/lima/lima_gem_prime.c
@@ -1,47 +1,47 @@
 // SPDX-License-Identifier: GPL-2.0 OR MIT
-/* Copyright 2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2018-2019 Qiang Yu <yuq825@gmail.com> */
 
 #include <linux/dma-buf.h>
 #include <drm/drm_prime.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_file.h>
 
 #include "lima_device.h"
 #include "lima_object.h"
+#include "lima_gem.h"
 #include "lima_gem_prime.h"
 
 struct drm_gem_object *lima_gem_prime_import_sg_table(
 	struct drm_device *dev, struct dma_buf_attachment *attach,
 	struct sg_table *sgt)
 {
-	struct reservation_object *resv = attach->dmabuf->resv;
 	struct lima_device *ldev = to_lima_dev(dev);
 	struct lima_bo *bo;
 
-	ww_mutex_lock(&resv->lock, NULL);
-
-	bo = lima_bo_create(ldev, attach->dmabuf->size, 0,
-			    ttm_bo_type_sg, sgt, resv);
+	bo = lima_bo_create(ldev, attach->dmabuf->size, 0, sgt,
+			    attach->dmabuf->resv);
 	if (IS_ERR(bo))
-		goto err_out;
+		return ERR_CAST(bo);
 
-	ww_mutex_unlock(&resv->lock);
 	return &bo->gem;
-
-err_out:
-	ww_mutex_unlock(&resv->lock);
-	return (void *)bo;
 }
 
-struct reservation_object *lima_gem_prime_res_obj(struct drm_gem_object *obj)
+struct sg_table *lima_gem_prime_get_sg_table(struct drm_gem_object *obj)
 {
-        struct lima_bo *bo = to_lima_bo(obj);
+	struct lima_bo *bo = to_lima_bo(obj);
+	int npages = obj->size >> PAGE_SHIFT;
 
-	return bo->tbo.resv;
+	return drm_prime_pages_to_sg(bo->pages, npages);
 }
 
-struct sg_table *lima_gem_prime_get_sg_table(struct drm_gem_object *obj)
+int lima_gem_prime_mmap(struct drm_gem_object *obj, struct vm_area_struct *vma)
 {
-	struct lima_bo *bo = to_lima_bo(obj);
-	int npages = bo->tbo.num_pages;
+	int ret;
+
+	ret = drm_gem_mmap_obj(obj, obj->size, vma);
+	if (ret)
+		return ret;
 
-	return drm_prime_pages_to_sg(bo->tbo.ttm->pages, npages);
+	lima_set_vma_flags(vma);
+	return 0;
 }
diff --git a/drivers/gpu/drm/lima/lima_gem_prime.h b/drivers/gpu/drm/lima/lima_gem_prime.h
index 6dea7dd65..34b4d35c2 100644
--- a/drivers/gpu/drm/lima/lima_gem_prime.h
+++ b/drivers/gpu/drm/lima/lima_gem_prime.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0 OR MIT */
-/* Copyright 2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2018-2019 Qiang Yu <yuq825@gmail.com> */
 
 #ifndef __LIMA_GEM_PRIME_H__
 #define __LIMA_GEM_PRIME_H__
@@ -8,6 +8,6 @@ struct drm_gem_object *lima_gem_prime_import_sg_table(
 	struct drm_device *dev, struct dma_buf_attachment *attach,
 	struct sg_table *sgt);
 struct sg_table *lima_gem_prime_get_sg_table(struct drm_gem_object *obj);
-struct reservation_object *lima_gem_prime_res_obj(struct drm_gem_object *obj);
+int lima_gem_prime_mmap(struct drm_gem_object *obj, struct vm_area_struct *vma);
 
 #endif
diff --git a/drivers/gpu/drm/lima/lima_gp.c b/drivers/gpu/drm/lima/lima_gp.c
index 6c902648e..ccf49faed 100644
--- a/drivers/gpu/drm/lima/lima_gp.c
+++ b/drivers/gpu/drm/lima/lima_gp.c
@@ -1,8 +1,8 @@
 // SPDX-License-Identifier: GPL-2.0 OR MIT
-/* Copyright 2017-2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2017-2019 Qiang Yu <yuq825@gmail.com> */
 
 #include <linux/interrupt.h>
-#include <linux/io.h>
+#include <linux/iopoll.h>
 #include <linux/device.h>
 #include <linux/slab.h>
 
@@ -12,16 +12,16 @@
 #include "lima_gp.h"
 #include "lima_regs.h"
 
-#define gp_write(reg, data) writel(data, ip->iomem + LIMA_GP_##reg)
-#define gp_read(reg) readl(ip->iomem + LIMA_GP_##reg)
+#define gp_write(reg, data) writel(data, ip->iomem + reg)
+#define gp_read(reg) readl(ip->iomem + reg)
 
 static irqreturn_t lima_gp_irq_handler(int irq, void *data)
 {
 	struct lima_ip *ip = data;
 	struct lima_device *dev = ip->dev;
 	struct lima_sched_pipe *pipe = dev->pipe + lima_pipe_gp;
-	u32 state = gp_read(INT_STAT);
-	u32 status = gp_read(STATUS);
+	u32 state = gp_read(LIMA_GP_INT_STAT);
+	u32 status = gp_read(LIMA_GP_STATUS);
 	bool done = false;
 
 	/* for shared irq case */
@@ -33,12 +33,11 @@ static irqreturn_t lima_gp_irq_handler(int irq, void *data)
 			state, status);
 
 		/* mask all interrupts before hard reset */
-		gp_write(INT_MASK, 0);
+		gp_write(LIMA_GP_INT_MASK, 0);
 
 		pipe->error = true;
 		done = true;
-	}
-	else {
+	} else {
 		bool valid = state & (LIMA_GP_IRQ_VS_END_CMD_LST |
 				      LIMA_GP_IRQ_PLBU_END_CMD_LST);
 		bool active = status & (LIMA_GP_STATUS_VS_ACTIVE |
@@ -46,7 +45,7 @@ static irqreturn_t lima_gp_irq_handler(int irq, void *data)
 		done = valid && !active;
 	}
 
-	gp_write(INT_CLEAR, state);
+	gp_write(LIMA_GP_INT_CLEAR, state);
 
 	if (done)
 		lima_sched_pipe_task_done(pipe);
@@ -59,31 +58,31 @@ static void lima_gp_soft_reset_async(struct lima_ip *ip)
 	if (ip->data.async_reset)
 		return;
 
-	gp_write(INT_MASK, 0);
-	gp_write(INT_CLEAR, LIMA_GP_IRQ_RESET_COMPLETED);
-	gp_write(CMD, LIMA_GP_CMD_SOFT_RESET);
+	gp_write(LIMA_GP_INT_MASK, 0);
+	gp_write(LIMA_GP_INT_CLEAR, LIMA_GP_IRQ_RESET_COMPLETED);
+	gp_write(LIMA_GP_CMD, LIMA_GP_CMD_SOFT_RESET);
 	ip->data.async_reset = true;
 }
 
 static int lima_gp_soft_reset_async_wait(struct lima_ip *ip)
 {
 	struct lima_device *dev = ip->dev;
-	int timeout;
+	int err;
+	u32 v;
 
 	if (!ip->data.async_reset)
 		return 0;
 
-	for (timeout = 1000; timeout > 0; timeout--) {
-		if (gp_read(INT_RAWSTAT) & LIMA_GP_IRQ_RESET_COMPLETED)
-			break;
-	}
-	if (!timeout) {
+	err = readl_poll_timeout(ip->iomem + LIMA_GP_INT_RAWSTAT, v,
+				 v & LIMA_GP_IRQ_RESET_COMPLETED,
+				 0, 100);
+	if (err) {
 		dev_err(dev->dev, "gp soft reset time out\n");
-		return -ETIMEDOUT;
+		return err;
 	}
 
-	gp_write(INT_CLEAR, LIMA_GP_IRQ_MASK_ALL);
-	gp_write(INT_MASK, LIMA_GP_IRQ_MASK_USED);
+	gp_write(LIMA_GP_INT_CLEAR, LIMA_GP_IRQ_MASK_ALL);
+	gp_write(LIMA_GP_INT_MASK, LIMA_GP_IRQ_MASK_USED);
 
 	ip->data.async_reset = false;
 	return 0;
@@ -135,31 +134,33 @@ static void lima_gp_task_run(struct lima_sched_pipe *pipe,
 	for (i = 0; i < LIMA_GP_FRAME_REG_NUM; i++)
 		writel(f[i], ip->iomem + LIMA_GP_VSCL_START_ADDR + i * 4);
 
-	gp_write(CMD, LIMA_GP_CMD_UPDATE_PLBU_ALLOC);
-	gp_write(CMD, cmd);
+	gp_write(LIMA_GP_CMD, LIMA_GP_CMD_UPDATE_PLBU_ALLOC);
+	gp_write(LIMA_GP_CMD, cmd);
+}
+
+static int lima_gp_hard_reset_poll(struct lima_ip *ip)
+{
+	gp_write(LIMA_GP_PERF_CNT_0_LIMIT, 0xC01A0000);
+	return gp_read(LIMA_GP_PERF_CNT_0_LIMIT) == 0xC01A0000;
 }
 
 static int lima_gp_hard_reset(struct lima_ip *ip)
 {
 	struct lima_device *dev = ip->dev;
-	int timeout;
-
-	gp_write(PERF_CNT_0_LIMIT, 0xC0FFE000);
-	gp_write(INT_MASK, 0);
-	gp_write(CMD, LIMA_GP_CMD_RESET);
-	for (timeout = 1000; timeout > 0; timeout--) {
-		gp_write(PERF_CNT_0_LIMIT, 0xC01A0000);
-		if (gp_read(PERF_CNT_0_LIMIT) == 0xC01A0000)
-			break;
-	}
-	if (!timeout) {
+	int ret;
+
+	gp_write(LIMA_GP_PERF_CNT_0_LIMIT, 0xC0FFE000);
+	gp_write(LIMA_GP_INT_MASK, 0);
+	gp_write(LIMA_GP_CMD, LIMA_GP_CMD_RESET);
+	ret = lima_poll_timeout(ip, lima_gp_hard_reset_poll, 10, 100);
+	if (ret) {
 		dev_err(dev->dev, "gp hard reset timeout\n");
-		return -ETIMEDOUT;
+		return ret;
 	}
 
-	gp_write(PERF_CNT_0_LIMIT, 0);
-	gp_write(INT_CLEAR, LIMA_GP_IRQ_MASK_ALL);
-	gp_write(INT_MASK, LIMA_GP_IRQ_MASK_USED);
+	gp_write(LIMA_GP_PERF_CNT_0_LIMIT, 0);
+	gp_write(LIMA_GP_INT_CLEAR, LIMA_GP_IRQ_MASK_ALL);
+	gp_write(LIMA_GP_INT_MASK, LIMA_GP_IRQ_MASK_USED);
 	return 0;
 }
 
@@ -170,7 +171,12 @@ static void lima_gp_task_fini(struct lima_sched_pipe *pipe)
 
 static void lima_gp_task_error(struct lima_sched_pipe *pipe)
 {
-	lima_gp_hard_reset(pipe->processor[0]);
+	struct lima_ip *ip = pipe->processor[0];
+
+	dev_err(ip->dev->dev, "gp task error int_state=%x status=%x\n",
+		gp_read(LIMA_GP_INT_STAT), gp_read(LIMA_GP_STATUS));
+
+	lima_gp_hard_reset(ip);
 }
 
 static void lima_gp_task_mmu_error(struct lima_sched_pipe *pipe)
@@ -183,7 +189,7 @@ static void lima_gp_print_version(struct lima_ip *ip)
 	u32 version, major, minor;
 	char *name;
 
-	version = gp_read(VERSION);
+	version = gp_read(LIMA_GP_VERSION);
 	major = (version >> 8) & 0xFF;
 	minor = version & 0xFF;
 	switch (version >> 16) {
@@ -200,15 +206,15 @@ static void lima_gp_print_version(struct lima_ip *ip)
 		name = "mali450";
 		break;
 	default:
-		name = "unknow";
+		name = "unknown";
 		break;
 	}
 	dev_info(ip->dev->dev, "%s - %s version major %d minor %d\n",
 		 lima_ip_name(ip), name, major, minor);
 }
 
-static struct kmem_cache *lima_gp_task_slab = NULL;
-static int lima_gp_task_slab_refcnt = 0;
+static struct kmem_cache *lima_gp_task_slab;
+static int lima_gp_task_slab_refcnt;
 
 int lima_gp_init(struct lima_ip *ip)
 {
@@ -231,6 +237,8 @@ int lima_gp_init(struct lima_ip *ip)
 		return err;
 	}
 
+	dev->gp_version = gp_read(LIMA_GP_VERSION);
+
 	return 0;
 }
 
diff --git a/drivers/gpu/drm/lima/lima_gp.h b/drivers/gpu/drm/lima/lima_gp.h
index 55bc48ec7..516e5c1ba 100644
--- a/drivers/gpu/drm/lima/lima_gp.h
+++ b/drivers/gpu/drm/lima/lima_gp.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0 OR MIT */
-/* Copyright 2017-2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2017-2019 Qiang Yu <yuq825@gmail.com> */
 
 #ifndef __LIMA_GP_H__
 #define __LIMA_GP_H__
diff --git a/drivers/gpu/drm/lima/lima_l2_cache.c b/drivers/gpu/drm/lima/lima_l2_cache.c
index e7cdec720..6873a7af5 100644
--- a/drivers/gpu/drm/lima/lima_l2_cache.c
+++ b/drivers/gpu/drm/lima/lima_l2_cache.c
@@ -1,28 +1,28 @@
 // SPDX-License-Identifier: GPL-2.0 OR MIT
-/* Copyright 2017-2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2017-2019 Qiang Yu <yuq825@gmail.com> */
 
-#include <linux/io.h>
+#include <linux/iopoll.h>
 #include <linux/device.h>
 
 #include "lima_device.h"
 #include "lima_l2_cache.h"
 #include "lima_regs.h"
 
-#define l2_cache_write(reg, data) writel(data, ip->iomem + LIMA_L2_CACHE_##reg)
-#define l2_cache_read(reg) readl(ip->iomem + LIMA_L2_CACHE_##reg)
+#define l2_cache_write(reg, data) writel(data, ip->iomem + reg)
+#define l2_cache_read(reg) readl(ip->iomem + reg)
 
 static int lima_l2_cache_wait_idle(struct lima_ip *ip)
 {
-	int timeout;
 	struct lima_device *dev = ip->dev;
-
-	for (timeout = 100000; timeout > 0; timeout--) {
-	    if (!(l2_cache_read(STATUS) & LIMA_L2_CACHE_STATUS_COMMAND_BUSY))
-		break;
-	}
-	if (!timeout) {
-	    dev_err(dev->dev, "l2 cache wait command timeout\n");
-	    return -ETIMEDOUT;
+	int err;
+	u32 v;
+
+	err = readl_poll_timeout(ip->iomem + LIMA_L2_CACHE_STATUS, v,
+				 !(v & LIMA_L2_CACHE_STATUS_COMMAND_BUSY),
+				 0, 1000);
+	if (err) {
+		dev_err(dev->dev, "l2 cache wait command timeout\n");
+		return err;
 	}
 	return 0;
 }
@@ -32,7 +32,7 @@ int lima_l2_cache_flush(struct lima_ip *ip)
 	int ret;
 
 	spin_lock(&ip->data.lock);
-	l2_cache_write(COMMAND, LIMA_L2_CACHE_COMMAND_CLEAR_ALL);
+	l2_cache_write(LIMA_L2_CACHE_COMMAND, LIMA_L2_CACHE_COMMAND_CLEAR_ALL);
 	ret = lima_l2_cache_wait_idle(ip);
 	spin_unlock(&ip->data.lock);
 	return ret;
@@ -56,7 +56,7 @@ int lima_l2_cache_init(struct lima_ip *ip)
 
 	spin_lock_init(&ip->data.lock);
 
-	size = l2_cache_read(SIZE);
+	size = l2_cache_read(LIMA_L2_CACHE_SIZE);
 	dev_info(dev->dev, "l2 cache %uK, %u-way, %ubyte cache line, %ubit external bus\n",
 		 1 << (((size >> 16) & 0xff) - 10),
 		 1 << ((size >> 8) & 0xff),
@@ -67,8 +67,9 @@ int lima_l2_cache_init(struct lima_ip *ip)
 	if (err)
 		return err;
 
-	l2_cache_write(ENABLE, LIMA_L2_CACHE_ENABLE_ACCESS | LIMA_L2_CACHE_ENABLE_READ_ALLOCATE);
-	l2_cache_write(MAX_READS, 0x1c);
+	l2_cache_write(LIMA_L2_CACHE_ENABLE,
+		       LIMA_L2_CACHE_ENABLE_ACCESS|LIMA_L2_CACHE_ENABLE_READ_ALLOCATE);
+	l2_cache_write(LIMA_L2_CACHE_MAX_READS, 0x1c);
 
 	return 0;
 }
diff --git a/drivers/gpu/drm/lima/lima_l2_cache.h b/drivers/gpu/drm/lima/lima_l2_cache.h
index 2ff91eafe..c63fb676f 100644
--- a/drivers/gpu/drm/lima/lima_l2_cache.h
+++ b/drivers/gpu/drm/lima/lima_l2_cache.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0 OR MIT */
-/* Copyright 2017-2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2017-2019 Qiang Yu <yuq825@gmail.com> */
 
 #ifndef __LIMA_L2_CACHE_H__
 #define __LIMA_L2_CACHE_H__
diff --git a/drivers/gpu/drm/lima/lima_mmu.c b/drivers/gpu/drm/lima/lima_mmu.c
index 234fb90a4..8e1651d6a 100644
--- a/drivers/gpu/drm/lima/lima_mmu.c
+++ b/drivers/gpu/drm/lima/lima_mmu.c
@@ -1,8 +1,8 @@
 // SPDX-License-Identifier: GPL-2.0 OR MIT
-/* Copyright 2017-2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2017-2019 Qiang Yu <yuq825@gmail.com> */
 
 #include <linux/interrupt.h>
-#include <linux/io.h>
+#include <linux/iopoll.h>
 #include <linux/device.h>
 
 #include "lima_device.h"
@@ -11,22 +11,19 @@
 #include "lima_object.h"
 #include "lima_regs.h"
 
-#define mmu_write(reg, data) writel(data, ip->iomem + LIMA_MMU_##reg)
-#define mmu_read(reg) readl(ip->iomem + LIMA_MMU_##reg)
+#define mmu_write(reg, data) writel(data, ip->iomem + reg)
+#define mmu_read(reg) readl(ip->iomem + reg)
 
-#define lima_mmu_send_command(command, condition)	     \
+#define lima_mmu_send_command(cmd, addr, val, cond)	     \
 ({							     \
-	int __timeout, __ret = 0;			     \
+	int __ret;					     \
 							     \
-	mmu_write(COMMAND, command);			     \
-	for (__timeout = 1000; __timeout > 0; __timeout--) { \
-		if (condition)				     \
-			break;				     \
-	}						     \
-	if (!__timeout)	{				     \
-		dev_err(dev->dev, "mmu command %x timeout\n", command); \
-		__ret = -ETIMEDOUT;			     \
-	}						     \
+	mmu_write(LIMA_MMU_COMMAND, cmd);		     \
+	__ret = readl_poll_timeout(ip->iomem + (addr), val,  \
+				  cond, 0, 100);	     \
+	if (__ret)					     \
+		dev_err(dev->dev,			     \
+			"mmu command %x timeout\n", cmd);    \
 	__ret;						     \
 })
 
@@ -34,7 +31,7 @@ static irqreturn_t lima_mmu_irq_handler(int irq, void *data)
 {
 	struct lima_ip *ip = data;
 	struct lima_device *dev = ip->dev;
-	u32 status = mmu_read(INT_STATUS);
+	u32 status = mmu_read(LIMA_MMU_INT_STATUS);
 	struct lima_sched_pipe *pipe;
 
 	/* for shared irq case */
@@ -42,20 +39,20 @@ static irqreturn_t lima_mmu_irq_handler(int irq, void *data)
 		return IRQ_NONE;
 
 	if (status & LIMA_MMU_INT_PAGE_FAULT) {
-		u32 fault = mmu_read(PAGE_FAULT_ADDR);
+		u32 fault = mmu_read(LIMA_MMU_PAGE_FAULT_ADDR);
+
 		dev_err(dev->dev, "mmu page fault at 0x%x from bus id %d of type %s on %s\n",
 			fault, LIMA_MMU_STATUS_BUS_ID(status),
 			status & LIMA_MMU_STATUS_PAGE_FAULT_IS_WRITE ? "write" : "read",
 			lima_ip_name(ip));
 	}
 
-	if (status & LIMA_MMU_INT_READ_BUS_ERROR) {
+	if (status & LIMA_MMU_INT_READ_BUS_ERROR)
 		dev_err(dev->dev, "mmu %s irq bus error\n", lima_ip_name(ip));
-	}
 
 	/* mask all interrupts before resume */
-	mmu_write(INT_MASK, 0);
-	mmu_write(INT_CLEAR, status);
+	mmu_write(LIMA_MMU_INT_MASK, 0);
+	mmu_write(LIMA_MMU_INT_CLEAR, status);
 
 	pipe = dev->pipe + (ip->id == lima_ip_gpmmu ? lima_pipe_gp : lima_pipe_pp);
 	lima_sched_pipe_mmu_error(pipe);
@@ -67,17 +64,20 @@ int lima_mmu_init(struct lima_ip *ip)
 {
 	struct lima_device *dev = ip->dev;
 	int err;
+	u32 v;
 
 	if (ip->id == lima_ip_ppmmu_bcast)
 		return 0;
 
-	mmu_write(DTE_ADDR, 0xCAFEBABE);
-	if (mmu_read(DTE_ADDR) != 0xCAFEB000) {
+	mmu_write(LIMA_MMU_DTE_ADDR, 0xCAFEBABE);
+	if (mmu_read(LIMA_MMU_DTE_ADDR) != 0xCAFEB000) {
 		dev_err(dev->dev, "mmu %s dte write test fail\n", lima_ip_name(ip));
 		return -EIO;
 	}
 
-	err = lima_mmu_send_command(LIMA_MMU_COMMAND_HARD_RESET, mmu_read(DTE_ADDR) == 0);
+	mmu_write(LIMA_MMU_COMMAND, LIMA_MMU_COMMAND_HARD_RESET);
+	err = lima_mmu_send_command(LIMA_MMU_COMMAND_HARD_RESET,
+				    LIMA_MMU_DTE_ADDR, v, v == 0);
 	if (err)
 		return err;
 
@@ -88,10 +88,11 @@ int lima_mmu_init(struct lima_ip *ip)
 		return err;
 	}
 
-	mmu_write(INT_MASK, LIMA_MMU_INT_PAGE_FAULT | LIMA_MMU_INT_READ_BUS_ERROR);
-	mmu_write(DTE_ADDR, *lima_bo_get_pages(dev->empty_vm->pd));
+	mmu_write(LIMA_MMU_INT_MASK, LIMA_MMU_INT_PAGE_FAULT | LIMA_MMU_INT_READ_BUS_ERROR);
+	mmu_write(LIMA_MMU_DTE_ADDR, dev->empty_vm->pd.dma);
 	return lima_mmu_send_command(LIMA_MMU_COMMAND_ENABLE_PAGING,
-				     mmu_read(STATUS) & LIMA_MMU_STATUS_PAGING_ENABLED);
+				     LIMA_MMU_STATUS, v,
+				     v & LIMA_MMU_STATUS_PAGING_ENABLED);
 }
 
 void lima_mmu_fini(struct lima_ip *ip)
@@ -102,34 +103,40 @@ void lima_mmu_fini(struct lima_ip *ip)
 void lima_mmu_switch_vm(struct lima_ip *ip, struct lima_vm *vm)
 {
 	struct lima_device *dev = ip->dev;
+	u32 v;
 
 	lima_mmu_send_command(LIMA_MMU_COMMAND_ENABLE_STALL,
-			      mmu_read(STATUS) & LIMA_MMU_STATUS_STALL_ACTIVE);
+			      LIMA_MMU_STATUS, v,
+			      v & LIMA_MMU_STATUS_STALL_ACTIVE);
 
 	if (vm)
-		mmu_write(DTE_ADDR, *lima_bo_get_pages(vm->pd));
+		mmu_write(LIMA_MMU_DTE_ADDR, vm->pd.dma);
 
 	/* flush the TLB */
-	mmu_write(COMMAND, LIMA_MMU_COMMAND_ZAP_CACHE);
+	mmu_write(LIMA_MMU_COMMAND, LIMA_MMU_COMMAND_ZAP_CACHE);
 
 	lima_mmu_send_command(LIMA_MMU_COMMAND_DISABLE_STALL,
-			      !(mmu_read(STATUS) & LIMA_MMU_STATUS_STALL_ACTIVE));
+			      LIMA_MMU_STATUS, v,
+			      !(v & LIMA_MMU_STATUS_STALL_ACTIVE));
 }
 
 void lima_mmu_page_fault_resume(struct lima_ip *ip)
 {
 	struct lima_device *dev = ip->dev;
-	u32 status = mmu_read(STATUS);
+	u32 status = mmu_read(LIMA_MMU_STATUS);
+	u32 v;
 
 	if (status & LIMA_MMU_STATUS_PAGE_FAULT_ACTIVE) {
 		dev_info(dev->dev, "mmu resume\n");
 
-		mmu_write(INT_MASK, 0);
-		mmu_write(DTE_ADDR, 0xCAFEBABE);
-		lima_mmu_send_command(LIMA_MMU_COMMAND_HARD_RESET, mmu_read(DTE_ADDR) == 0);
-	        mmu_write(INT_MASK, LIMA_MMU_INT_PAGE_FAULT | LIMA_MMU_INT_READ_BUS_ERROR);
-		mmu_write(DTE_ADDR, *lima_bo_get_pages(dev->empty_vm->pd));
+		mmu_write(LIMA_MMU_INT_MASK, 0);
+		mmu_write(LIMA_MMU_DTE_ADDR, 0xCAFEBABE);
+		lima_mmu_send_command(LIMA_MMU_COMMAND_HARD_RESET,
+				      LIMA_MMU_DTE_ADDR, v, v == 0);
+		mmu_write(LIMA_MMU_INT_MASK, LIMA_MMU_INT_PAGE_FAULT | LIMA_MMU_INT_READ_BUS_ERROR);
+		mmu_write(LIMA_MMU_DTE_ADDR, dev->empty_vm->pd.dma);
 		lima_mmu_send_command(LIMA_MMU_COMMAND_ENABLE_PAGING,
-				      mmu_read(STATUS) & LIMA_MMU_STATUS_PAGING_ENABLED);
+				      LIMA_MMU_STATUS, v,
+				      v & LIMA_MMU_STATUS_PAGING_ENABLED);
 	}
 }
diff --git a/drivers/gpu/drm/lima/lima_mmu.h b/drivers/gpu/drm/lima/lima_mmu.h
index ca173b60f..8c78319bc 100644
--- a/drivers/gpu/drm/lima/lima_mmu.h
+++ b/drivers/gpu/drm/lima/lima_mmu.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0 OR MIT */
-/* Copyright 2017-2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2017-2019 Qiang Yu <yuq825@gmail.com> */
 
 #ifndef __LIMA_MMU_H__
 #define __LIMA_MMU_H__
diff --git a/drivers/gpu/drm/lima/lima_object.c b/drivers/gpu/drm/lima/lima_object.c
index 34d9b4dc2..5c41f859a 100644
--- a/drivers/gpu/drm/lima/lima_object.c
+++ b/drivers/gpu/drm/lima/lima_object.c
@@ -1,103 +1,122 @@
 // SPDX-License-Identifier: GPL-2.0 OR MIT
-/* Copyright 2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2018-2019 Qiang Yu <yuq825@gmail.com> */
 
 #include <drm/drm_prime.h>
-#include <drm/drm_fourcc.h>
+#include <linux/pagemap.h>
+#include <linux/dma-mapping.h>
 
 #include "lima_object.h"
 
-static void lima_bo_init_placement(struct lima_bo *bo)
+void lima_bo_destroy(struct lima_bo *bo)
 {
-	struct ttm_placement *placement = &bo->placement;
-	struct ttm_place *place = &bo->place;
-
-	place->fpfn = 0;
-	place->lpfn = 0;
-	place->flags = TTM_PL_FLAG_TT | TTM_PL_FLAG_WC;
-
-	/* pin all bo for now */
-	place->flags |= TTM_PL_FLAG_NO_EVICT;
-
-	placement->num_placement = 1;
-	placement->placement = place;
-
-	placement->num_busy_placement = 1;
-	placement->busy_placement = place;
-}
-
-static void lima_bo_destroy(struct ttm_buffer_object *tbo)
-{
-	struct lima_bo *bo = ttm_to_lima_bo(tbo);
-
-	if (bo->gem.import_attach)
-		drm_prime_gem_destroy(&bo->gem, bo->tbo.sg);
+	if (bo->sgt) {
+		kfree(bo->pages);
+		drm_prime_gem_destroy(&bo->gem, bo->sgt);
+	} else {
+		if (bo->pages_dma_addr) {
+			int i, npages = bo->gem.size >> PAGE_SHIFT;
+
+			for (i = 0; i < npages; i++) {
+				if (bo->pages_dma_addr[i])
+					dma_unmap_page(bo->gem.dev->dev,
+						       bo->pages_dma_addr[i],
+						       PAGE_SIZE, DMA_BIDIRECTIONAL);
+			}
+		}
+
+		if (bo->pages)
+			drm_gem_put_pages(&bo->gem, bo->pages, true, true);
+	}
+
+	kfree(bo->pages_dma_addr);
 	drm_gem_object_release(&bo->gem);
 	kfree(bo);
 }
 
-struct lima_bo *lima_bo_create(struct lima_device *dev, u64 size,
-			       u32 flags, enum ttm_bo_type type,
-			       struct sg_table *sg,
-			       struct reservation_object *resv)
+static struct lima_bo *lima_bo_create_struct(struct lima_device *dev, u32 size, u32 flags,
+					     struct reservation_object *resv)
 {
 	struct lima_bo *bo;
-	struct ttm_mem_type_manager *man;
-	size_t acc_size;
 	int err;
 
 	size = PAGE_ALIGN(size);
-	man = dev->mman.bdev.man + TTM_PL_TT;
-	if (size >= (man->size << PAGE_SHIFT))
-		return ERR_PTR(-ENOMEM);
-
-	acc_size = ttm_bo_dma_acc_size(&dev->mman.bdev, size,
-				       sizeof(struct lima_bo));
 
 	bo = kzalloc(sizeof(*bo), GFP_KERNEL);
 	if (!bo)
 		return ERR_PTR(-ENOMEM);
 
-	drm_gem_private_object_init(dev->ddev, &bo->gem, size);
-
+	mutex_init(&bo->lock);
 	INIT_LIST_HEAD(&bo->va);
+	bo->gem.resv = resv;
 
-	bo->tbo.bdev = &dev->mman.bdev;
-
-	lima_bo_init_placement(bo);
-
-	err = ttm_bo_init(&dev->mman.bdev, &bo->tbo, size, type,
-			  &bo->placement, 0, type != ttm_bo_type_kernel,
-			  acc_size, sg, resv, &lima_bo_destroy);
-	if (err)
-		goto err_out;
+	err = drm_gem_object_init(dev->ddev, &bo->gem, size);
+	if (err) {
+		kfree(bo);
+		return ERR_PTR(err);
+	}
 
-	bo->modifier = DRM_FORMAT_MOD_INVALID;
 	return bo;
-
-err_out:
-	kfree(bo);
-	return ERR_PTR(err);
 }
 
-dma_addr_t *lima_bo_get_pages(struct lima_bo *bo)
+struct lima_bo *lima_bo_create(struct lima_device *dev, u32 size,
+			       u32 flags, struct sg_table *sgt,
+			       struct reservation_object *resv)
 {
-	struct lima_ttm_tt *ttm = (void *)bo->tbo.ttm;
-	return ttm->ttm.dma_address;
-}
+	int i, err;
+	size_t npages;
+	struct lima_bo *bo, *ret;
 
-void *lima_bo_kmap(struct lima_bo *bo)
-{
-	bool is_iomem;
-	void *ret;
-	int err;
+	bo = lima_bo_create_struct(dev, size, flags, resv);
+	if (IS_ERR(bo))
+		return bo;
 
-	ret = ttm_kmap_obj_virtual(&bo->kmap, &is_iomem);
-	if (ret)
-		return ret;
+	npages = bo->gem.size >> PAGE_SHIFT;
 
-	err = ttm_bo_kmap(&bo->tbo, 0, bo->tbo.num_pages, &bo->kmap);
-	if (err)
-		return ERR_PTR(err);
+	bo->pages_dma_addr = kcalloc(npages, sizeof(dma_addr_t), GFP_KERNEL);
+	if (!bo->pages_dma_addr) {
+		ret = ERR_PTR(-ENOMEM);
+		goto err_out;
+	}
+
+	if (sgt) {
+		bo->sgt = sgt;
+
+		bo->pages = kcalloc(npages, sizeof(*bo->pages), GFP_KERNEL);
+		if (!bo->pages) {
+			ret = ERR_PTR(-ENOMEM);
+			goto err_out;
+		}
+
+		err = drm_prime_sg_to_page_addr_arrays(
+			sgt, bo->pages, bo->pages_dma_addr, npages);
+		if (err) {
+			ret = ERR_PTR(err);
+			goto err_out;
+		}
+	} else {
+		mapping_set_gfp_mask(bo->gem.filp->f_mapping, GFP_DMA32);
+		bo->pages = drm_gem_get_pages(&bo->gem);
+		if (IS_ERR(bo->pages)) {
+			ret = ERR_CAST(bo->pages);
+			bo->pages = NULL;
+			goto err_out;
+		}
+
+		for (i = 0; i < npages; i++) {
+			dma_addr_t addr = dma_map_page(dev->dev, bo->pages[i], 0,
+						       PAGE_SIZE, DMA_BIDIRECTIONAL);
+			if (dma_mapping_error(dev->dev, addr)) {
+				ret = ERR_PTR(-EFAULT);
+				goto err_out;
+			}
+			bo->pages_dma_addr[i] = addr;
+		}
+
+	}
 
-	return ttm_kmap_obj_virtual(&bo->kmap, &is_iomem);
+	return bo;
+
+err_out:
+	lima_bo_destroy(bo);
+	return ret;
 }
diff --git a/drivers/gpu/drm/lima/lima_object.h b/drivers/gpu/drm/lima/lima_object.h
index f854a2563..6738724af 100644
--- a/drivers/gpu/drm/lima/lima_object.h
+++ b/drivers/gpu/drm/lima/lima_object.h
@@ -1,26 +1,23 @@
 /* SPDX-License-Identifier: GPL-2.0 OR MIT */
-/* Copyright 2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2018-2019 Qiang Yu <yuq825@gmail.com> */
 
 #ifndef __LIMA_OBJECT_H__
 #define __LIMA_OBJECT_H__
 
 #include <drm/drm_gem.h>
-#include <drm/ttm/ttm_placement.h>
-#include <drm/ttm/ttm_bo_api.h>
 
 #include "lima_device.h"
 
 struct lima_bo {
 	struct drm_gem_object gem;
 
-	struct ttm_place place;
-	struct ttm_placement placement;
-	struct ttm_buffer_object tbo;
-	struct ttm_bo_kmap_obj kmap;
+	struct page **pages;
+	dma_addr_t *pages_dma_addr;
+	struct sg_table *sgt;
+	void *vaddr;
 
+	struct mutex lock;
 	struct list_head va;
-
-	u64 modifier;
 };
 
 static inline struct lima_bo *
@@ -29,43 +26,11 @@ to_lima_bo(struct drm_gem_object *obj)
 	return container_of(obj, struct lima_bo, gem);
 }
 
-static inline struct lima_bo *
-ttm_to_lima_bo(struct ttm_buffer_object *tbo)
-{
-	return container_of(tbo, struct lima_bo, tbo);
-}
-
-static inline int lima_bo_reserve(struct lima_bo *bo, bool intr)
-{
-	struct lima_device *dev = ttm_to_lima_dev(bo->tbo.bdev);
-	int r;
-
-	r = ttm_bo_reserve(&bo->tbo, intr, false, NULL);
-	if (unlikely(r != 0)) {
-		if (r != -ERESTARTSYS)
-			dev_err(dev->dev, "%p reserve failed\n", bo);
-		return r;
-	}
-	return 0;
-}
-
-static inline void lima_bo_unreserve(struct lima_bo *bo)
-{
-	ttm_bo_unreserve(&bo->tbo);
-}
-
-struct lima_bo *lima_bo_create(struct lima_device *dev, u64 size,
-			       u32 flags, enum ttm_bo_type type,
-			       struct sg_table *sg,
+struct lima_bo *lima_bo_create(struct lima_device *dev, u32 size,
+			       u32 flags, struct sg_table *sgt,
 			       struct reservation_object *resv);
-
-static inline void lima_bo_unref(struct lima_bo *bo)
-{
-	struct ttm_buffer_object *tbo = &bo->tbo;
-	ttm_bo_unref(&tbo);
-}
-
-dma_addr_t *lima_bo_get_pages(struct lima_bo *bo);
-void *lima_bo_kmap(struct lima_bo *bo);
+void lima_bo_destroy(struct lima_bo *bo);
+void *lima_bo_vmap(struct lima_bo *bo);
+void lima_bo_vunmap(struct lima_bo *bo);
 
 #endif
diff --git a/drivers/gpu/drm/lima/lima_pmu.c b/drivers/gpu/drm/lima/lima_pmu.c
index e852077c1..571f6d661 100644
--- a/drivers/gpu/drm/lima/lima_pmu.c
+++ b/drivers/gpu/drm/lima/lima_pmu.c
@@ -1,34 +1,31 @@
 // SPDX-License-Identifier: GPL-2.0 OR MIT
-/* Copyright 2017-2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2017-2019 Qiang Yu <yuq825@gmail.com> */
 
-#include <linux/of.h>
-#include <linux/io.h>
+#include <linux/iopoll.h>
 #include <linux/device.h>
 
 #include "lima_device.h"
 #include "lima_pmu.h"
 #include "lima_regs.h"
 
-#define pmu_write(reg, data) writel(data, ip->iomem + LIMA_PMU_##reg)
-#define pmu_read(reg) readl(ip->iomem + LIMA_PMU_##reg)
+#define pmu_write(reg, data) writel(data, ip->iomem + reg)
+#define pmu_read(reg) readl(ip->iomem + reg)
 
 static int lima_pmu_wait_cmd(struct lima_ip *ip)
 {
 	struct lima_device *dev = ip->dev;
-	u32 stat, timeout;
-
-	for (timeout = 1000000; timeout > 0; timeout--) {
-		stat = pmu_read(INT_RAWSTAT);
-		if (stat & LIMA_PMU_INT_CMD_MASK)
-			break;
-	}
+	int err;
+	u32 v;
 
-	if (!timeout) {
+	err = readl_poll_timeout(ip->iomem + LIMA_PMU_INT_RAWSTAT,
+				 v, v & LIMA_PMU_INT_CMD_MASK,
+				 100, 100000);
+	if (err) {
 		dev_err(dev->dev, "timeout wait pmd cmd\n");
-		return -ETIMEDOUT;
+		return err;
 	}
 
-	pmu_write(INT_CLEAR, LIMA_PMU_INT_CMD_MASK);
+	pmu_write(LIMA_PMU_INT_CLEAR, LIMA_PMU_INT_CMD_MASK);
 	return 0;
 }
 
@@ -36,23 +33,20 @@ int lima_pmu_init(struct lima_ip *ip)
 {
 	int err;
 	u32 stat;
-	struct lima_device *dev = ip->dev;
-	struct device_node *np = dev->dev->of_node;
 
-	/* If this value is too low, when in high GPU clk freq,
-	 * GPU will be in unstable state. */
-	if (of_property_read_u32(np, "switch-delay", &ip->data.switch_delay))
-		ip->data.switch_delay = 0xff;
+	pmu_write(LIMA_PMU_INT_MASK, 0);
 
-	pmu_write(INT_MASK, 0);
-	pmu_write(SW_DELAY, ip->data.switch_delay);
+	/* If this value is too low, when in high GPU clk freq,
+	 * GPU will be in unstable state.
+	 */
+	pmu_write(LIMA_PMU_SW_DELAY, 0xffff);
 
 	/* status reg 1=off 0=on */
-	stat = pmu_read(STATUS);
+	stat = pmu_read(LIMA_PMU_STATUS);
 
 	/* power up all ip */
 	if (stat) {
-		pmu_write(POWER_UP, stat);
+		pmu_write(LIMA_PMU_POWER_UP, stat);
 		err = lima_pmu_wait_cmd(ip);
 		if (err)
 			return err;
diff --git a/drivers/gpu/drm/lima/lima_pmu.h b/drivers/gpu/drm/lima/lima_pmu.h
index 1cf94a35b..a2a18775e 100644
--- a/drivers/gpu/drm/lima/lima_pmu.h
+++ b/drivers/gpu/drm/lima/lima_pmu.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0 OR MIT */
-/* Copyright 2017-2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2017-2019 Qiang Yu <yuq825@gmail.com> */
 
 #ifndef __LIMA_PMU_H__
 #define __LIMA_PMU_H__
diff --git a/drivers/gpu/drm/lima/lima_pp.c b/drivers/gpu/drm/lima/lima_pp.c
index 502190d1b..d29721e17 100644
--- a/drivers/gpu/drm/lima/lima_pp.c
+++ b/drivers/gpu/drm/lima/lima_pp.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0 OR MIT
-/* Copyright 2017-2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2017-2019 Qiang Yu <yuq825@gmail.com> */
 
 #include <linux/interrupt.h>
 #include <linux/io.h>
@@ -15,8 +15,8 @@
 #include "lima_vm.h"
 #include "lima_regs.h"
 
-#define pp_write(reg, data) writel(data, ip->iomem + LIMA_PP_##reg)
-#define pp_read(reg) readl(ip->iomem + LIMA_PP_##reg)
+#define pp_write(reg, data) writel(data, ip->iomem + reg)
+#define pp_read(reg) readl(ip->iomem + reg)
 
 static void lima_pp_handle_irq(struct lima_ip *ip, u32 state)
 {
@@ -24,7 +24,7 @@ static void lima_pp_handle_irq(struct lima_ip *ip, u32 state)
 	struct lima_sched_pipe *pipe = dev->pipe + lima_pipe_pp;
 
 	if (state & LIMA_PP_IRQ_MASK_ERROR) {
-		u32 status = pp_read(STATUS);
+		u32 status = pp_read(LIMA_PP_STATUS);
 
 		dev_err(dev->dev, "pp error irq state=%x status=%x\n",
 			state, status);
@@ -32,10 +32,10 @@ static void lima_pp_handle_irq(struct lima_ip *ip, u32 state)
 		pipe->error = true;
 
 		/* mask all interrupts before hard reset */
-		pp_write(INT_MASK, 0);
+		pp_write(LIMA_PP_INT_MASK, 0);
 	}
 
-	pp_write(INT_CLEAR, state);
+	pp_write(LIMA_PP_INT_CLEAR, state);
 }
 
 static irqreturn_t lima_pp_irq_handler(int irq, void *data)
@@ -43,7 +43,7 @@ static irqreturn_t lima_pp_irq_handler(int irq, void *data)
 	struct lima_ip *ip = data;
 	struct lima_device *dev = ip->dev;
 	struct lima_sched_pipe *pipe = dev->pipe + lima_pipe_pp;
-	u32 state = pp_read(INT_STATUS);
+	u32 state = pp_read(LIMA_PP_INT_STATUS);
 
 	/* for shared irq case */
 	if (!state)
@@ -74,15 +74,15 @@ static irqreturn_t lima_pp_bcast_irq_handler(int irq, void *data)
 			continue;
 
 		/* status read first in case int state change in the middle
-		 * which may miss the interrupt handling */
-		status = pp_read(STATUS);
-		state = pp_read(INT_STATUS);
+		 * which may miss the interrupt handling
+		 */
+		status = pp_read(LIMA_PP_STATUS);
+		state = pp_read(LIMA_PP_INT_STATUS);
 
 		if (state) {
 			lima_pp_handle_irq(ip, state);
 			ret = IRQ_HANDLED;
-		}
-		else {
+		} else {
 			if (status & LIMA_PP_STATUS_RENDERING_ACTIVE)
 				continue;
 		}
@@ -100,29 +100,31 @@ static void lima_pp_soft_reset_async(struct lima_ip *ip)
 	if (ip->data.async_reset)
 		return;
 
-	pp_write(INT_MASK, 0);
-	pp_write(INT_RAWSTAT, LIMA_PP_IRQ_MASK_ALL);
-	pp_write(CTRL, LIMA_PP_CTRL_SOFT_RESET);
+	pp_write(LIMA_PP_INT_MASK, 0);
+	pp_write(LIMA_PP_INT_RAWSTAT, LIMA_PP_IRQ_MASK_ALL);
+	pp_write(LIMA_PP_CTRL, LIMA_PP_CTRL_SOFT_RESET);
 	ip->data.async_reset = true;
 }
 
+static int lima_pp_soft_reset_poll(struct lima_ip *ip)
+{
+	return !(pp_read(LIMA_PP_STATUS) & LIMA_PP_STATUS_RENDERING_ACTIVE) &&
+		pp_read(LIMA_PP_INT_RAWSTAT) == LIMA_PP_IRQ_RESET_COMPLETED;
+}
+
 static int lima_pp_soft_reset_async_wait_one(struct lima_ip *ip)
 {
 	struct lima_device *dev = ip->dev;
-	int timeout;
+	int ret;
 
-	for (timeout = 1000; timeout > 0; timeout--) {
-		if (!(pp_read(STATUS) & LIMA_PP_STATUS_RENDERING_ACTIVE) &&
-		    pp_read(INT_RAWSTAT) == LIMA_PP_IRQ_RESET_COMPLETED)
-			break;
-	}
-	if (!timeout) {
+	ret = lima_poll_timeout(ip, lima_pp_soft_reset_poll, 0, 100);
+	if (ret) {
 		dev_err(dev->dev, "pp %s reset time out\n", lima_ip_name(ip));
-		return -ETIMEDOUT;
+		return ret;
 	}
 
-	pp_write(INT_CLEAR, LIMA_PP_IRQ_MASK_ALL);
-	pp_write(INT_MASK, LIMA_PP_IRQ_MASK_USED);
+	pp_write(LIMA_PP_INT_CLEAR, LIMA_PP_IRQ_MASK_ALL);
+	pp_write(LIMA_PP_INT_MASK, LIMA_PP_IRQ_MASK_USED);
 	return 0;
 }
 
@@ -140,8 +142,7 @@ static int lima_pp_soft_reset_async_wait(struct lima_ip *ip)
 
 		for (i = 0; i < frame->num_pp; i++)
 			err |= lima_pp_soft_reset_async_wait_one(pipe->processor[i]);
-	}
-	else
+	} else
 		err = lima_pp_soft_reset_async_wait_one(ip);
 
 	ip->data.async_reset = false;
@@ -161,27 +162,29 @@ static void lima_pp_write_frame(struct lima_ip *ip, u32 *frame, u32 *wb)
 	}
 }
 
+static int lima_pp_hard_reset_poll(struct lima_ip *ip)
+{
+	pp_write(LIMA_PP_PERF_CNT_0_LIMIT, 0xC01A0000);
+	return pp_read(LIMA_PP_PERF_CNT_0_LIMIT) == 0xC01A0000;
+}
+
 static int lima_pp_hard_reset(struct lima_ip *ip)
 {
 	struct lima_device *dev = ip->dev;
-	int timeout;
-
-	pp_write(PERF_CNT_0_LIMIT, 0xC0FFE000);
-	pp_write(INT_MASK, 0);
-	pp_write(CTRL, LIMA_PP_CTRL_FORCE_RESET);
-	for (timeout = 1000; timeout > 0; timeout--) {
-		pp_write(PERF_CNT_0_LIMIT, 0xC01A0000);
-		if (pp_read(PERF_CNT_0_LIMIT) == 0xC01A0000)
-			break;
-	}
-	if (!timeout) {
+	int ret;
+
+	pp_write(LIMA_PP_PERF_CNT_0_LIMIT, 0xC0FFE000);
+	pp_write(LIMA_PP_INT_MASK, 0);
+	pp_write(LIMA_PP_CTRL, LIMA_PP_CTRL_FORCE_RESET);
+	ret = lima_poll_timeout(ip, lima_pp_hard_reset_poll, 10, 100);
+	if (ret) {
 		dev_err(dev->dev, "pp hard reset timeout\n");
-		return -ETIMEDOUT;
+		return ret;
 	}
 
-	pp_write(PERF_CNT_0_LIMIT, 0);
-	pp_write(INT_CLEAR, LIMA_PP_IRQ_MASK_ALL);
-	pp_write(INT_MASK, LIMA_PP_IRQ_MASK_USED);
+	pp_write(LIMA_PP_PERF_CNT_0_LIMIT, 0);
+	pp_write(LIMA_PP_INT_CLEAR, LIMA_PP_IRQ_MASK_ALL);
+	pp_write(LIMA_PP_INT_MASK, LIMA_PP_IRQ_MASK_USED);
 	return 0;
 }
 
@@ -190,7 +193,7 @@ static void lima_pp_print_version(struct lima_ip *ip)
 	u32 version, major, minor;
 	char *name;
 
-	version = pp_read(VERSION);
+	version = pp_read(LIMA_PP_VERSION);
 	major = (version >> 8) & 0xFF;
 	minor = version & 0xFF;
 	switch (version >> 16) {
@@ -207,7 +210,7 @@ static void lima_pp_print_version(struct lima_ip *ip)
 		name = "mali450";
 		break;
 	default:
-		name = "unknow";
+		name = "unknown";
 		break;
 	}
 	dev_info(ip->dev->dev, "%s - %s version major %d minor %d\n",
@@ -235,12 +238,14 @@ int lima_pp_init(struct lima_ip *ip)
 		return err;
 	}
 
+	dev->pp_version = pp_read(LIMA_PP_VERSION);
+
 	return 0;
 }
 
 void lima_pp_fini(struct lima_ip *ip)
 {
-	
+
 }
 
 int lima_pp_bcast_init(struct lima_ip *ip)
@@ -261,7 +266,7 @@ int lima_pp_bcast_init(struct lima_ip *ip)
 
 void lima_pp_bcast_fini(struct lima_ip *ip)
 {
-	
+
 }
 
 static int lima_pp_task_validate(struct lima_sched_pipe *pipe,
@@ -271,10 +276,14 @@ static int lima_pp_task_validate(struct lima_sched_pipe *pipe,
 
 	if (pipe->bcast_processor) {
 		struct drm_lima_m450_pp_frame *f = task->frame;
-	        num_pp = f->num_pp;
-	}
-	else {
+
+		num_pp = f->num_pp;
+
+		if (f->_pad)
+			return -EINVAL;
+	} else {
 		struct drm_lima_m400_pp_frame *f = task->frame;
+
 		num_pp = f->num_pp;
 	}
 
@@ -299,29 +308,27 @@ static void lima_pp_task_run(struct lima_sched_pipe *pipe,
 		if (frame->use_dlbu) {
 			lima_dlbu_enable(dev, frame->num_pp);
 
-		        frame->frame[LIMA_PP_FRAME >> 2] = LIMA_VA_RESERVE_DLBU;
+			frame->frame[LIMA_PP_FRAME >> 2] = LIMA_VA_RESERVE_DLBU;
 			lima_dlbu_set_reg(dev->ip + lima_ip_dlbu, frame->dlbu_regs);
-		}
-		else
+		} else
 			lima_dlbu_disable(dev);
 
 		lima_bcast_enable(dev, frame->num_pp);
 
 		lima_pp_soft_reset_async_wait(ip);
 
-	        lima_pp_write_frame(ip, frame->frame, frame->wb);
+		lima_pp_write_frame(ip, frame->frame, frame->wb);
 
 		for (i = 0; i < frame->num_pp; i++) {
 			struct lima_ip *ip = pipe->processor[i];
 
-			pp_write(STACK, frame->fragment_stack_address[i]);
+			pp_write(LIMA_PP_STACK, frame->fragment_stack_address[i]);
 			if (!frame->use_dlbu)
-				pp_write(FRAME, frame->plbu_array_address[i]);
+				pp_write(LIMA_PP_FRAME, frame->plbu_array_address[i]);
 		}
 
-		pp_write(CTRL, LIMA_PP_CTRL_START_RENDERING);
-	}
-	else {
+		pp_write(LIMA_PP_CTRL, LIMA_PP_CTRL_START_RENDERING);
+	} else {
 		struct drm_lima_m400_pp_frame *frame = task->frame;
 		int i;
 
@@ -337,9 +344,9 @@ static void lima_pp_task_run(struct lima_sched_pipe *pipe,
 
 			lima_pp_soft_reset_async_wait(ip);
 
-		        lima_pp_write_frame(ip, frame->frame, frame->wb);
+			lima_pp_write_frame(ip, frame->frame, frame->wb);
 
-			pp_write(CTRL, LIMA_PP_CTRL_START_RENDERING);
+			pp_write(LIMA_PP_CTRL, LIMA_PP_CTRL_START_RENDERING);
 		}
 	}
 }
@@ -350,6 +357,7 @@ static void lima_pp_task_fini(struct lima_sched_pipe *pipe)
 		lima_pp_soft_reset_async(pipe->bcast_processor);
 	else {
 		int i;
+
 		for (i = 0; i < pipe->num_processor; i++)
 			lima_pp_soft_reset_async(pipe->processor[i]);
 	}
@@ -359,8 +367,14 @@ static void lima_pp_task_error(struct lima_sched_pipe *pipe)
 {
 	int i;
 
-	for (i = 0; i < pipe->num_processor; i++)
-		lima_pp_hard_reset(pipe->processor[i]);
+	for (i = 0; i < pipe->num_processor; i++) {
+		struct lima_ip *ip = pipe->processor[i];
+
+		dev_err(ip->dev->dev, "pp task error %d int_state=%x status=%x\n",
+			i, pp_read(LIMA_PP_INT_STATUS), pp_read(LIMA_PP_STATUS));
+
+		lima_pp_hard_reset(ip);
+	}
 }
 
 static void lima_pp_task_mmu_error(struct lima_sched_pipe *pipe)
@@ -369,8 +383,8 @@ static void lima_pp_task_mmu_error(struct lima_sched_pipe *pipe)
 		lima_sched_pipe_task_done(pipe);
 }
 
-static struct kmem_cache *lima_pp_task_slab = NULL;
-static int lima_pp_task_slab_refcnt = 0;
+static struct kmem_cache *lima_pp_task_slab;
+static int lima_pp_task_slab_refcnt;
 
 int lima_pp_pipe_init(struct lima_device *dev)
 {
diff --git a/drivers/gpu/drm/lima/lima_pp.h b/drivers/gpu/drm/lima/lima_pp.h
index f83f8cb4d..bf60c77b2 100644
--- a/drivers/gpu/drm/lima/lima_pp.h
+++ b/drivers/gpu/drm/lima/lima_pp.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0 OR MIT */
-/* Copyright 2017-2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2017-2019 Qiang Yu <yuq825@gmail.com> */
 
 #ifndef __LIMA_PP_H__
 #define __LIMA_PP_H__
diff --git a/drivers/gpu/drm/lima/lima_regs.h b/drivers/gpu/drm/lima/lima_regs.h
index d5ade8fc8..ace8ecefb 100644
--- a/drivers/gpu/drm/lima/lima_regs.h
+++ b/drivers/gpu/drm/lima/lima_regs.h
@@ -1,6 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0 */
 /* Copyright 2010-2017 ARM Limited. All rights reserved.
- * Copyright 2017-2018 Qiang Yu <yuq825@gmail.com>
+ * Copyright 2017-2019 Qiang Yu <yuq825@gmail.com>
  */
 
 #ifndef __LIMA_REGS_H__
@@ -154,7 +154,7 @@
 #define LIMA_PP_STACK			     0x0030
 #define LIMA_PP_STACK_SIZE		     0x0034
 #define LIMA_PP_ORIGIN_OFFSET_X	             0x0040
-#define LIMA_PP_WB(i) 			     (0x0100 * (i + 1))
+#define LIMA_PP_WB(i)                        (0x0100 * (i + 1))
 #define   LIMA_PP_WB_SOURCE_SELECT           0x0000
 #define	  LIMA_PP_WB_SOURCE_ADDR             0x0004
 
@@ -275,12 +275,12 @@
 		LIMA_VM_FLAG_WRITE_CACHEABLE |	 \
 		LIMA_VM_FLAG_WRITE_BUFFERABLE |	 \
 		LIMA_VM_FLAG_READ_CACHEABLE |	 \
-		LIMA_VM_FLAG_READ_ALLOCATE )
+		LIMA_VM_FLAG_READ_ALLOCATE)
 
 #define LIMA_VM_FLAGS_UNCACHE (			\
 		LIMA_VM_FLAG_PRESENT |		\
 		LIMA_VM_FLAG_READ_PERMISSION |	\
-		LIMA_VM_FLAG_WRITE_PERMISSION )
+		LIMA_VM_FLAG_WRITE_PERMISSION)
 
 /* DLBU regs */
 #define LIMA_DLBU_MASTER_TLLIST_PHYS_ADDR  0x0000
diff --git a/drivers/gpu/drm/lima/lima_sched.c b/drivers/gpu/drm/lima/lima_sched.c
index d09aae446..97bd9c1de 100644
--- a/drivers/gpu/drm/lima/lima_sched.c
+++ b/drivers/gpu/drm/lima/lima_sched.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0 OR MIT
-/* Copyright 2017-2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2017-2019 Qiang Yu <yuq825@gmail.com> */
 
 #include <linux/kthread.h>
 #include <linux/slab.h>
@@ -9,29 +9,36 @@
 #include "lima_vm.h"
 #include "lima_mmu.h"
 #include "lima_l2_cache.h"
+#include "lima_object.h"
 
 struct lima_fence {
 	struct dma_fence base;
 	struct lima_sched_pipe *pipe;
 };
 
-static struct kmem_cache *lima_fence_slab = NULL;
+static struct kmem_cache *lima_fence_slab;
+static int lima_fence_slab_refcnt;
 
 int lima_sched_slab_init(void)
 {
-	lima_fence_slab = kmem_cache_create(
-		"lima_fence", sizeof(struct lima_fence), 0,
-		SLAB_HWCACHE_ALIGN, NULL);
-	if (!lima_fence_slab)
-		return -ENOMEM;
+	if (!lima_fence_slab) {
+		lima_fence_slab = kmem_cache_create(
+			"lima_fence", sizeof(struct lima_fence), 0,
+			SLAB_HWCACHE_ALIGN, NULL);
+		if (!lima_fence_slab)
+			return -ENOMEM;
+	}
 
+	lima_fence_slab_refcnt++;
 	return 0;
 }
 
 void lima_sched_slab_fini(void)
 {
-	if (lima_fence_slab)
+	if (!--lima_fence_slab_refcnt) {
 		kmem_cache_destroy(lima_fence_slab);
+		lima_fence_slab = NULL;
+	}
 }
 
 static inline struct lima_fence *to_lima_fence(struct dma_fence *fence)
@@ -51,11 +58,6 @@ static const char *lima_fence_get_timeline_name(struct dma_fence *fence)
 	return f->pipe->base.name;
 }
 
-static bool lima_fence_enable_signaling(struct dma_fence *fence)
-{
-	return true;
-}
-
 static void lima_fence_release_rcu(struct rcu_head *rcu)
 {
 	struct dma_fence *f = container_of(rcu, struct dma_fence, rcu);
@@ -74,8 +76,6 @@ static void lima_fence_release(struct dma_fence *fence)
 static const struct dma_fence_ops lima_fence_ops = {
 	.get_driver_name = lima_fence_get_driver_name,
 	.get_timeline_name = lima_fence_get_timeline_name,
-	.enable_signaling = lima_fence_enable_signaling,
-	.wait = dma_fence_default_wait,
 	.release = lima_fence_release,
 };
 
@@ -85,7 +85,7 @@ static struct lima_fence *lima_fence_create(struct lima_sched_pipe *pipe)
 
 	fence = kmem_cache_zalloc(lima_fence_slab, GFP_KERNEL);
 	if (!fence)
-	       return NULL;
+		return NULL;
 
 	fence->pipe = pipe;
 	dma_fence_init(&fence->base, &lima_fence_ops, &pipe->fence_lock,
@@ -106,21 +106,47 @@ static inline struct lima_sched_pipe *to_lima_pipe(struct drm_gpu_scheduler *sch
 
 int lima_sched_task_init(struct lima_sched_task *task,
 			 struct lima_sched_context *context,
+			 struct lima_bo **bos, int num_bos,
 			 struct lima_vm *vm)
 {
-	int err;
+	int err, i;
+
+	task->bos = kmemdup(bos, sizeof(*bos) * num_bos, GFP_KERNEL);
+	if (!task->bos)
+		return -ENOMEM;
+
+	for (i = 0; i < num_bos; i++)
+		drm_gem_object_get(&bos[i]->gem);
 
 	err = drm_sched_job_init(&task->base, &context->base, vm);
-	if (err)
+	if (err) {
+		kfree(task->bos);
 		return err;
+	}
 
+	task->num_bos = num_bos;
 	task->vm = lima_vm_get(vm);
 	return 0;
 }
 
 void lima_sched_task_fini(struct lima_sched_task *task)
 {
-	dma_fence_put(&task->base.s_fence->finished);
+	int i;
+
+	drm_sched_job_cleanup(&task->base);
+
+	for (i = 0; i < task->num_dep; i++)
+		dma_fence_put(task->dep[i]);
+
+	kfree(task->dep);
+
+	if (task->bos) {
+		for (i = 0; i < task->num_bos; i++)
+			drm_gem_object_put_unlocked(&task->bos[i]->gem);
+		kfree(task->bos);
+	}
+
+	lima_vm_put(task->vm);
 }
 
 int lima_sched_task_add_dep(struct lima_sched_task *task, struct dma_fence *fence)
@@ -128,16 +154,20 @@ int lima_sched_task_add_dep(struct lima_sched_task *task, struct dma_fence *fenc
 	int i, new_dep = 4;
 
 	/* same context's fence is definitly earlier then this task */
-	if (fence->context == task->base.s_fence->finished.context)
+	if (fence->context == task->base.s_fence->finished.context) {
+		dma_fence_put(fence);
 		return 0;
+	}
 
 	if (task->dep && task->num_dep == task->max_dep)
 		new_dep = task->max_dep * 2;
 
 	if (task->max_dep < new_dep) {
 		void *dep = krealloc(task->dep, sizeof(*task->dep) * new_dep, GFP_KERNEL);
+
 		if (!dep)
 			return -ENOMEM;
+
 		task->max_dep = new_dep;
 		task->dep = dep;
 	}
@@ -160,109 +190,23 @@ int lima_sched_context_init(struct lima_sched_pipe *pipe,
 			    atomic_t *guilty)
 {
 	struct drm_sched_rq *rq = pipe->base.sched_rq + DRM_SCHED_PRIORITY_NORMAL;
-	int err;
-
-	context->fences =
-		kzalloc(sizeof(*context->fences) * lima_sched_max_tasks, GFP_KERNEL);
-	if (!context->fences)
-		return -ENOMEM;
 
-	mutex_init(&context->lock);
-	err = drm_sched_entity_init(&context->base, &rq, 1, guilty);
-	if (err) {
-		kfree(context->fences);
-		context->fences = NULL;
-		return err;
-	}
-
-	return 0;
+	return drm_sched_entity_init(&context->base, &rq, 1, guilty);
 }
 
 void lima_sched_context_fini(struct lima_sched_pipe *pipe,
 			     struct lima_sched_context *context)
 {
 	drm_sched_entity_fini(&context->base);
-
-	mutex_destroy(&context->lock);
-
-	if (context->fences)
-		kfree(context->fences);
 }
 
-static uint32_t lima_sched_context_add_fence(struct lima_sched_context *context,
-					     struct dma_fence *fence,
-					     uint32_t *done)
+struct dma_fence *lima_sched_context_queue_task(struct lima_sched_context *context,
+						struct lima_sched_task *task)
 {
-	uint32_t seq, idx, i;
-	struct dma_fence *other;
-
-	mutex_lock(&context->lock);
-
-	seq = context->sequence;
-	idx = seq & (lima_sched_max_tasks - 1);
-	other = context->fences[idx];
-
-	if (other) {
-		int err = dma_fence_wait(other, false);
-		if (err)
-			DRM_ERROR("Error %d waiting context fence\n", err);
-	}
+	struct dma_fence *fence = dma_fence_get(&task->base.s_fence->finished);
 
-	context->fences[idx] = dma_fence_get(fence);
-	context->sequence++;
-
-	/* get finished fence offset from seq */
-	for (i = 1; i < lima_sched_max_tasks; i++) {
-		idx = (seq - i) & (lima_sched_max_tasks - 1);
-		if (!context->fences[idx] ||
-		    dma_fence_is_signaled(context->fences[idx]))
-			break;
-	}
-
-	mutex_unlock(&context->lock);
-
-	dma_fence_put(other);
-
-	*done = i;
-	return seq;
-}
-
-struct dma_fence *lima_sched_context_get_fence(
-	struct lima_sched_context *context, uint32_t seq)
-{
-	struct dma_fence *fence;
-	int idx;
-	uint32_t max, min;
-
-	mutex_lock(&context->lock);
-
-	max = context->sequence - 1;
-	min = context->sequence - lima_sched_max_tasks;
-
-	/* handle overflow case */
-	if ((min < max && (seq < min || seq > max)) ||
-	    (min > max && (seq < min && seq > max))) {
-		    fence = NULL;
-		    goto out;
-	}
-
-	idx = seq & (lima_sched_max_tasks - 1);
-	fence = dma_fence_get(context->fences[idx]);
-
-out:
-	mutex_unlock(&context->lock);
-
-	return fence;
-}
-
-uint32_t lima_sched_context_queue_task(struct lima_sched_context *context,
-				       struct lima_sched_task *task,
-				       uint32_t *done)
-{
-	uint32_t seq = lima_sched_context_add_fence(
-		context, &task->base.s_fence->finished, done);
 	drm_sched_entity_push_job(&task->base, &context->base);
-	return seq;
+	return fence;
 }
 
 static struct dma_fence *lima_sched_dependency(struct drm_sched_job *job,
@@ -306,8 +250,9 @@ static struct dma_fence *lima_sched_run_job(struct drm_sched_job *job)
 		return NULL;
 	task->fence = &fence->base;
 
-	/* for caller usage of the fence, otherwise irq handler 
-	 * may consume the fence before caller use it */
+	/* for caller usage of the fence, otherwise irq handler
+	 * may consume the fence before caller use it
+	 */
 	ret = dma_fence_get(task->fence);
 
 	pipe->current_task = task;
@@ -355,8 +300,10 @@ static struct dma_fence *lima_sched_run_job(struct drm_sched_job *job)
 static void lima_sched_handle_error_task(struct lima_sched_pipe *pipe,
 					 struct lima_sched_task *task)
 {
-	kthread_park(pipe->base.thread);
-	drm_sched_hw_job_reset(&pipe->base, &task->base);
+	drm_sched_stop(&pipe->base);
+
+	if (task)
+		drm_sched_increase_karma(&task->base);
 
 	pipe->task_error(pipe);
 
@@ -364,6 +311,7 @@ static void lima_sched_handle_error_task(struct lima_sched_pipe *pipe,
 		lima_mmu_page_fault_resume(pipe->bcast_mmu);
 	else {
 		int i;
+
 		for (i = 0; i < pipe->num_mmu; i++)
 			lima_mmu_page_fault_resume(pipe->mmu[i]);
 	}
@@ -374,8 +322,8 @@ static void lima_sched_handle_error_task(struct lima_sched_pipe *pipe,
 	pipe->current_vm = NULL;
 	pipe->current_task = NULL;
 
-	drm_sched_job_recovery(&pipe->base);
-	kthread_unpark(pipe->base.thread);
+	drm_sched_resubmit_jobs(&pipe->base);
+	drm_sched_start(&pipe->base, true);
 }
 
 static void lima_sched_timedout_job(struct drm_sched_job *job)
@@ -383,6 +331,8 @@ static void lima_sched_timedout_job(struct drm_sched_job *job)
 	struct lima_sched_pipe *pipe = to_lima_pipe(job->sched);
 	struct lima_sched_task *task = to_lima_task(job);
 
+	DRM_ERROR("lima job timeout\n");
+
 	lima_sched_handle_error_task(pipe, task);
 }
 
@@ -390,19 +340,16 @@ static void lima_sched_free_job(struct drm_sched_job *job)
 {
 	struct lima_sched_task *task = to_lima_task(job);
 	struct lima_sched_pipe *pipe = to_lima_pipe(job->sched);
+	struct lima_vm *vm = task->vm;
+	struct lima_bo **bos = task->bos;
 	int i;
 
 	dma_fence_put(task->fence);
 
-	for (i = 0; i < task->num_dep; i++) {
-		if (task->dep[i])
-			dma_fence_put(task->dep[i]);
-	}
-
-	if (task->dep)
-		kfree(task->dep);
+	for (i = 0; i < task->num_bos; i++)
+		lima_vm_bo_del(vm, bos[i]);
 
-	lima_vm_put(task->vm);
+	lima_sched_task_fini(task);
 	kmem_cache_free(pipe->task_slab, task);
 }
 
@@ -444,31 +391,10 @@ void lima_sched_pipe_fini(struct lima_sched_pipe *pipe)
 	drm_sched_fini(&pipe->base);
 }
 
-unsigned long lima_timeout_to_jiffies(u64 timeout_ns)
-{
-	unsigned long timeout_jiffies;
-	ktime_t timeout;
-
-	/* clamp timeout if it's to large */
-	if (((s64)timeout_ns) < 0)
-		return MAX_SCHEDULE_TIMEOUT;
-
-	timeout = ktime_sub(ns_to_ktime(timeout_ns), ktime_get());
-	if (ktime_to_ns(timeout) < 0)
-		return 0;
-
-	timeout_jiffies = nsecs_to_jiffies(ktime_to_ns(timeout));
-	/*  clamp timeout to avoid unsigned-> signed overflow */
-	if (timeout_jiffies > MAX_SCHEDULE_TIMEOUT )
-		return MAX_SCHEDULE_TIMEOUT;
-
-	return timeout_jiffies;
-}
-
 void lima_sched_pipe_task_done(struct lima_sched_pipe *pipe)
 {
 	if (pipe->error)
-	        schedule_work(&pipe->error_work);
+		schedule_work(&pipe->error_work);
 	else {
 		struct lima_sched_task *task = pipe->current_task;
 
diff --git a/drivers/gpu/drm/lima/lima_sched.h b/drivers/gpu/drm/lima/lima_sched.h
index e13937671..b017cfa7e 100644
--- a/drivers/gpu/drm/lima/lima_sched.h
+++ b/drivers/gpu/drm/lima/lima_sched.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0 OR MIT */
-/* Copyright 2017-2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2017-2019 Qiang Yu <yuq825@gmail.com> */
 
 #ifndef __LIMA_SCHED_H__
 #define __LIMA_SCHED_H__
@@ -18,15 +18,15 @@ struct lima_sched_task {
 	int num_dep;
 	int max_dep;
 
+	struct lima_bo **bos;
+	int num_bos;
+
 	/* pipe fence */
 	struct dma_fence *fence;
 };
 
 struct lima_sched_context {
 	struct drm_sched_entity base;
-	struct mutex lock;
-	struct dma_fence **fences;
-	uint32_t sequence;
 };
 
 #define LIMA_SCHED_PIPE_MAX_MMU       8
@@ -75,6 +75,7 @@ struct lima_sched_pipe {
 
 int lima_sched_task_init(struct lima_sched_task *task,
 			 struct lima_sched_context *context,
+			 struct lima_bo **bos, int num_bos,
 			 struct lima_vm *vm);
 void lima_sched_task_fini(struct lima_sched_task *task);
 int lima_sched_task_add_dep(struct lima_sched_task *task, struct dma_fence *fence);
@@ -84,11 +85,8 @@ int lima_sched_context_init(struct lima_sched_pipe *pipe,
 			    atomic_t *guilty);
 void lima_sched_context_fini(struct lima_sched_pipe *pipe,
 			     struct lima_sched_context *context);
-uint32_t lima_sched_context_queue_task(struct lima_sched_context *context,
-				       struct lima_sched_task *task,
-				       uint32_t *done);
-struct dma_fence *lima_sched_context_get_fence(
-	struct lima_sched_context *context, uint32_t seq);
+struct dma_fence *lima_sched_context_queue_task(struct lima_sched_context *context,
+						struct lima_sched_task *task);
 
 int lima_sched_pipe_init(struct lima_sched_pipe *pipe, const char *name);
 void lima_sched_pipe_fini(struct lima_sched_pipe *pipe);
@@ -103,6 +101,4 @@ static inline void lima_sched_pipe_mmu_error(struct lima_sched_pipe *pipe)
 int lima_sched_slab_init(void);
 void lima_sched_slab_fini(void);
 
-unsigned long lima_timeout_to_jiffies(u64 timeout_ns);
-
 #endif
diff --git a/drivers/gpu/drm/lima/lima_ttm.c b/drivers/gpu/drm/lima/lima_ttm.c
deleted file mode 100644
index af46dd1ed..000000000
--- a/drivers/gpu/drm/lima/lima_ttm.c
+++ /dev/null
@@ -1,383 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0 OR MIT
-/* Copyright 2018 Qiang Yu <yuq825@gmail.com> */
-
-#include <linux/mm.h>
-#include <drm/ttm/ttm_page_alloc.h>
-
-#include "lima_drv.h"
-#include "lima_device.h"
-#include "lima_object.h"
-
-
-static int lima_ttm_mem_global_init(struct drm_global_reference *ref)
-{
-	return ttm_mem_global_init(ref->object);
-}
-
-static void lima_ttm_mem_global_release(struct drm_global_reference *ref)
-{
-	ttm_mem_global_release(ref->object);
-}
-
-static int lima_ttm_global_init(struct lima_device *dev)
-{
-	struct drm_global_reference *global_ref;
-	int err;
-
-	dev->mman.mem_global_referenced = false;
-	global_ref = &dev->mman.mem_global_ref;
-	global_ref->global_type = DRM_GLOBAL_TTM_MEM;
-	global_ref->size = sizeof(struct ttm_mem_global);
-	global_ref->init = &lima_ttm_mem_global_init;
-	global_ref->release = &lima_ttm_mem_global_release;
-
-	err = drm_global_item_ref(global_ref);
-	if (err != 0) {
-		dev_err(dev->dev, "Failed setting up TTM memory accounting "
-			"subsystem.\n");
-		return err;
-	}
-
-	dev->mman.bo_global_ref.mem_glob =
-		dev->mman.mem_global_ref.object;
-	global_ref = &dev->mman.bo_global_ref.ref;
-	global_ref->global_type = DRM_GLOBAL_TTM_BO;
-	global_ref->size = sizeof(struct ttm_bo_global);
-	global_ref->init = &ttm_bo_global_init;
-	global_ref->release = &ttm_bo_global_release;
-	err = drm_global_item_ref(global_ref);
-	if (err != 0) {
-		dev_err(dev->dev, "Failed setting up TTM BO subsystem.\n");
-		drm_global_item_unref(&dev->mman.mem_global_ref);
-		return err;
-	}
-
-	dev->mman.mem_global_referenced = true;
-	return 0;
-}
-
-static void lima_ttm_global_fini(struct lima_device *dev)
-{
-	if (dev->mman.mem_global_referenced) {
-		drm_global_item_unref(&dev->mman.bo_global_ref.ref);
-		drm_global_item_unref(&dev->mman.mem_global_ref);
-		dev->mman.mem_global_referenced = false;
-	}
-}
-
-struct lima_tt_mgr {
-	spinlock_t lock;
-	unsigned long available;
-};
-
-static int lima_ttm_bo_man_init(struct ttm_mem_type_manager *man,
-				unsigned long p_size)
-{
-	struct lima_tt_mgr *mgr;
-
-	mgr = kmalloc(sizeof(*mgr), GFP_KERNEL);
-	if (!mgr)
-		return -ENOMEM;
-
-	spin_lock_init(&mgr->lock);
-	mgr->available = p_size;
-	man->priv = mgr;
-	return 0;
-}
-
-static int lima_ttm_bo_man_takedown(struct ttm_mem_type_manager *man)
-{
-	struct lima_tt_mgr *mgr = man->priv;
-
-	kfree(mgr);
-	man->priv = NULL;
-	return 0;
-}
-
-static int lima_ttm_bo_man_get_node(struct ttm_mem_type_manager *man,
-				    struct ttm_buffer_object *bo,
-				    const struct ttm_place *place,
-				    struct ttm_mem_reg *mem)
-{
-	struct lima_tt_mgr *mgr = man->priv;
-
-	/* don't exceed the mem limit */
-	spin_lock(&mgr->lock);
-	if (mgr->available < mem->num_pages) {
-		spin_unlock(&mgr->lock);
-		return 0;
-	}
-	mgr->available -= mem->num_pages;
-	spin_unlock(&mgr->lock);
-
-	/* just fake a non-null pointer to tell caller success */
-	mem->mm_node = (void *)1;
-	return 0;
-}
-
-static void lima_ttm_bo_man_put_node(struct ttm_mem_type_manager *man,
-				     struct ttm_mem_reg *mem)
-{
-	struct lima_tt_mgr *mgr = man->priv;
-
-	spin_lock(&mgr->lock);
-	mgr->available += mem->num_pages;
-	spin_unlock(&mgr->lock);
-
-	mem->mm_node = NULL;
-}
-
-static void lima_ttm_bo_man_debug(struct ttm_mem_type_manager *man,
-				  struct drm_printer *printer)
-{
-}
-
-static const struct ttm_mem_type_manager_func lima_bo_manager_func = {
-	.init = lima_ttm_bo_man_init,
-	.takedown = lima_ttm_bo_man_takedown,
-	.get_node = lima_ttm_bo_man_get_node,
-	.put_node = lima_ttm_bo_man_put_node,
-	.debug = lima_ttm_bo_man_debug
-};
-
-static int lima_init_mem_type(struct ttm_bo_device *bdev, uint32_t type,
-			      struct ttm_mem_type_manager *man)
-{
-	struct lima_device *dev = ttm_to_lima_dev(bdev);
-
-	switch (type) {
-	case TTM_PL_SYSTEM:
-		/* System memory */
-		man->flags = TTM_MEMTYPE_FLAG_MAPPABLE;
-		man->available_caching = TTM_PL_MASK_CACHING;
-		man->default_caching = TTM_PL_FLAG_CACHED;
-		break;
-	case TTM_PL_TT:
-		man->func = &lima_bo_manager_func;
-		man->flags = TTM_MEMTYPE_FLAG_MAPPABLE;
-		man->available_caching = TTM_PL_MASK_CACHING;
-		man->default_caching = TTM_PL_FLAG_CACHED;
-		break;
-	default:
-		dev_err(dev->dev, "Unsupported memory type %u\n",
-			(unsigned int)type);
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static int lima_ttm_backend_bind(struct ttm_tt *ttm,
-				 struct ttm_mem_reg *bo_mem)
-{
-	return 0;
-}
-
-static int lima_ttm_backend_unbind(struct ttm_tt *ttm)
-{
-	return 0;
-}
-
-static void lima_ttm_backend_destroy(struct ttm_tt *ttm)
-{
-	struct lima_ttm_tt *tt = (void *)ttm;
-
-	ttm_dma_tt_fini(&tt->ttm);
-	kfree(tt);
-}
-
-static struct ttm_backend_func lima_ttm_backend_func = {
-	.bind = &lima_ttm_backend_bind,
-	.unbind = &lima_ttm_backend_unbind,
-	.destroy = &lima_ttm_backend_destroy,
-};
-
-static struct ttm_tt *lima_ttm_tt_create(struct ttm_buffer_object *bo,
-					 uint32_t page_flags)
-{
-	struct lima_ttm_tt *tt;
-
-	tt = kzalloc(sizeof(struct lima_ttm_tt), GFP_KERNEL);
-	if (tt == NULL)
-		return NULL;
-
-	tt->ttm.ttm.func = &lima_ttm_backend_func;
-
-	if (ttm_sg_tt_init(&tt->ttm, bo, page_flags)) {
-		kfree(tt);
-		return NULL;
-	}
-
-	return &tt->ttm.ttm;
-}
-
-static int lima_ttm_tt_populate(struct ttm_tt *ttm,
-				struct ttm_operation_ctx *ctx)
-{
-	struct lima_device *dev = ttm_to_lima_dev(ttm->bdev);
-	struct lima_ttm_tt *tt = (void *)ttm;
-	bool slave = !!(ttm->page_flags & TTM_PAGE_FLAG_SG);
-
-	if (slave) {
-		drm_prime_sg_to_page_addr_arrays(ttm->sg, ttm->pages,
-						 tt->ttm.dma_address,
-						 ttm->num_pages);
-		ttm->state = tt_unbound;
-		return 0;
-	}
-
-	return ttm_populate_and_map_pages(dev->dev, &tt->ttm, ctx);
-}
-
-static void lima_ttm_tt_unpopulate(struct ttm_tt *ttm)
-{
-	struct lima_device *dev = ttm_to_lima_dev(ttm->bdev);
-	struct lima_ttm_tt *tt = (void *)ttm;
-	bool slave = !!(ttm->page_flags & TTM_PAGE_FLAG_SG);
-
-	if (slave)
-		return;
-
-	ttm_unmap_and_unpopulate_pages(dev->dev, &tt->ttm);
-}
-
-static int lima_invalidate_caches(struct ttm_bo_device *bdev,
-				  uint32_t flags)
-{
-	struct lima_device *dev = ttm_to_lima_dev(bdev);
-
-	dev_err(dev->dev, "%s not implemented\n", __FUNCTION__);
-	return 0;
-}
-
-static void lima_evict_flags(struct ttm_buffer_object *tbo,
-			     struct ttm_placement *placement)
-{
-	struct lima_bo *bo = ttm_to_lima_bo(tbo);
-	struct lima_device *dev = to_lima_dev(bo->gem.dev);
-
-	dev_err(dev->dev, "%s not implemented\n", __FUNCTION__);
-}
-
-static int lima_verify_access(struct ttm_buffer_object *tbo,
-			      struct file *filp)
-{
-	struct lima_bo *bo = ttm_to_lima_bo(tbo);
-
-	return drm_vma_node_verify_access(&bo->gem.vma_node,
-					  filp->private_data);
-}
-
-static int lima_ttm_io_mem_reserve(struct ttm_bo_device *bdev,
-				   struct ttm_mem_reg *mem)
-{
-	struct ttm_mem_type_manager *man = &bdev->man[mem->mem_type];
-
-	mem->bus.addr = NULL;
-	mem->bus.offset = 0;
-	mem->bus.size = mem->num_pages << PAGE_SHIFT;
-	mem->bus.base = 0;
-	mem->bus.is_iomem = false;
-
-	if (!(man->flags & TTM_MEMTYPE_FLAG_MAPPABLE))
-		return -EINVAL;
-
-	switch (mem->mem_type) {
-	case TTM_PL_SYSTEM:
-	case TTM_PL_TT:
-		return 0;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static void lima_ttm_io_mem_free(struct ttm_bo_device *bdev,
-				 struct ttm_mem_reg *mem)
-{
-
-}
-
-static void lima_bo_move_notify(struct ttm_buffer_object *tbo, bool evict,
-				struct ttm_mem_reg *new_mem)
-{
-	struct lima_bo *bo = ttm_to_lima_bo(tbo);
-	struct lima_device *dev = to_lima_dev(bo->gem.dev);
-
-	if (evict)
-		dev_err(dev->dev, "%s not implemented\n", __FUNCTION__);
-}
-
-static void lima_bo_swap_notify(struct ttm_buffer_object *tbo)
-{
-	struct lima_bo *bo = ttm_to_lima_bo(tbo);
-	struct lima_device *dev = to_lima_dev(bo->gem.dev);
-
-	dev_err(dev->dev, "%s not implemented\n", __FUNCTION__);
-}
-
-static struct ttm_bo_driver lima_bo_driver = {
-	.ttm_tt_create = lima_ttm_tt_create,
-	.ttm_tt_populate = lima_ttm_tt_populate,
-	.ttm_tt_unpopulate = lima_ttm_tt_unpopulate,
-	.invalidate_caches = lima_invalidate_caches,
-	.init_mem_type = lima_init_mem_type,
-	.eviction_valuable = ttm_bo_eviction_valuable,
-	.evict_flags = lima_evict_flags,
-	.verify_access = lima_verify_access,
-	.io_mem_reserve = lima_ttm_io_mem_reserve,
-	.io_mem_free = lima_ttm_io_mem_free,
-	.move_notify = lima_bo_move_notify,
-	.swap_notify = lima_bo_swap_notify,
-};
-
-int lima_ttm_init(struct lima_device *dev)
-{
-	int err;
-	u64 gtt_size;
-
-	err = lima_ttm_global_init(dev);
-	if (err)
-		return err;
-
-	err = ttm_bo_device_init(&dev->mman.bdev,
-				 dev->mman.bo_global_ref.ref.object,
-				 &lima_bo_driver,
-				 dev->ddev->anon_inode->i_mapping,
-				 DRM_FILE_PAGE_OFFSET,
-				 true);
-	if (err) {
-		dev_err(dev->dev, "failed initializing buffer object "
-			"driver(%d).\n", err);
-		goto err_out0;
-	}
-
-	if (lima_max_mem < 0) {
-		struct sysinfo si;
-		si_meminfo(&si);
-		/* TODO: better to have lower 32 mem size */
-		gtt_size = min(((u64)si.totalram * si.mem_unit * 3/4),
-			       0x100000000ULL);
-	}
-	else
-		gtt_size = (u64)lima_max_mem << 20;
-
-	err = ttm_bo_init_mm(&dev->mman.bdev, TTM_PL_TT, gtt_size >> PAGE_SHIFT);
-	if (err) {
-		dev_err(dev->dev, "Failed initializing GTT heap.\n");
-		goto err_out1;
-	}
-	return 0;
-
-err_out1:
-	ttm_bo_device_release(&dev->mman.bdev);
-err_out0:
-	lima_ttm_global_fini(dev);
-	return err;
-}
-
-void lima_ttm_fini(struct lima_device *dev)
-{
-	ttm_bo_device_release(&dev->mman.bdev);
-	lima_ttm_global_fini(dev);
-	dev_info(dev->dev, "ttm finalized\n");
-}
diff --git a/drivers/gpu/drm/lima/lima_ttm.h b/drivers/gpu/drm/lima/lima_ttm.h
deleted file mode 100644
index df3c06aa9..000000000
--- a/drivers/gpu/drm/lima/lima_ttm.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 OR MIT */
-/* Copyright 2018 Qiang Yu <yuq825@gmail.com> */
-
-#ifndef __LIMA_TTM_H__
-#define __LIMA_TTM_H__
-
-#include <drm/ttm/ttm_bo_driver.h>
-
-struct lima_mman {
-	struct ttm_bo_global_ref bo_global_ref;
-	struct drm_global_reference mem_global_ref;
-	struct ttm_bo_device bdev;
-	bool mem_global_referenced;
-};
-
-struct lima_ttm_tt {
-	struct ttm_dma_tt ttm;
-};
-
-struct lima_device;
-struct lima_bo;
-
-int lima_ttm_init(struct lima_device *dev);
-void lima_ttm_fini(struct lima_device *dev);
-
-#endif
diff --git a/drivers/gpu/drm/lima/lima_vm.c b/drivers/gpu/drm/lima/lima_vm.c
index a264f3ae8..19e88ca16 100644
--- a/drivers/gpu/drm/lima/lima_vm.c
+++ b/drivers/gpu/drm/lima/lima_vm.c
@@ -1,28 +1,19 @@
 // SPDX-License-Identifier: GPL-2.0 OR MIT
-/* Copyright 2017-2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2017-2019 Qiang Yu <yuq825@gmail.com> */
 
 #include <linux/slab.h>
 #include <linux/dma-mapping.h>
-#include <linux/interval_tree_generic.h>
 
 #include "lima_device.h"
 #include "lima_vm.h"
 #include "lima_object.h"
 #include "lima_regs.h"
 
-struct lima_bo_va_mapping {
-	struct list_head list;
-	struct rb_node rb;
-	uint32_t start;
-	uint32_t last;
-	uint32_t __subtree_last;
-};
-
 struct lima_bo_va {
 	struct list_head list;
-	unsigned ref_count;
+	unsigned int ref_count;
 
-	struct list_head mapping;
+	struct drm_mm_node node;
 
 	struct lima_vm *vm;
 };
@@ -40,14 +31,6 @@ struct lima_bo_va {
 #define LIMA_PBE(va) (va >> LIMA_VM_PB_SHIFT)
 #define LIMA_BTE(va) ((va & LIMA_VM_BT_MASK) >> LIMA_VM_BT_SHIFT)
 
-#define START(node) ((node)->start)
-#define LAST(node) ((node)->last)
-
-INTERVAL_TREE_DEFINE(struct lima_bo_va_mapping, rb, uint32_t, __subtree_last,
-		     START, LAST, static, lima_vm_it)
-
-#undef START
-#undef LAST
 
 static void lima_vm_unmap_page_table(struct lima_vm *vm, u32 start, u32 end)
 {
@@ -56,10 +39,8 @@ static void lima_vm_unmap_page_table(struct lima_vm *vm, u32 start, u32 end)
 	for (addr = start; addr <= end; addr += LIMA_PAGE_SIZE) {
 		u32 pbe = LIMA_PBE(addr);
 		u32 bte = LIMA_BTE(addr);
-		u32 *bt;
 
-		bt = lima_bo_kmap(vm->bts[pbe]);
-		bt[bte] = 0;
+		vm->bts[pbe].cpu[bte] = 0;
 	}
 }
 
@@ -67,55 +48,38 @@ static int lima_vm_map_page_table(struct lima_vm *vm, dma_addr_t *dma,
 				  u32 start, u32 end)
 {
 	u64 addr;
-	int err, i = 0;
+	int i = 0;
 
 	for (addr = start; addr <= end; addr += LIMA_PAGE_SIZE) {
 		u32 pbe = LIMA_PBE(addr);
 		u32 bte = LIMA_BTE(addr);
-		u32 *bt;
 
-		if (vm->bts[pbe])
-			bt = lima_bo_kmap(vm->bts[pbe]);
-		else {
-			struct lima_bo *bt_bo;
-			dma_addr_t *pts;
+		if (!vm->bts[pbe].cpu) {
+			dma_addr_t pts;
 			u32 *pd;
 			int j;
 
-			bt_bo = lima_bo_create(
-				vm->dev, LIMA_PAGE_SIZE << LIMA_VM_NUM_PT_PER_BT_SHIFT,
-				0, ttm_bo_type_kernel,
-				NULL, vm->pd->tbo.resv);
-			if (IS_ERR(bt_bo)) {
-				err = PTR_ERR(bt_bo);
-				goto err_out;
+			vm->bts[pbe].cpu = dma_alloc_wc(
+				vm->dev->dev, LIMA_PAGE_SIZE << LIMA_VM_NUM_PT_PER_BT_SHIFT,
+				&vm->bts[pbe].dma, GFP_KERNEL | __GFP_ZERO);
+			if (!vm->bts[pbe].cpu) {
+				if (addr != start)
+					lima_vm_unmap_page_table(vm, start, addr - 1);
+				return -ENOMEM;
 			}
 
-			bt = lima_bo_kmap(bt_bo);
-			if (IS_ERR(bt)) {
-				lima_bo_unref(bt_bo);
-				err = PTR_ERR(bt);
-				goto err_out;
+			pts = vm->bts[pbe].dma;
+			pd = vm->pd.cpu + (pbe << LIMA_VM_NUM_PT_PER_BT_SHIFT);
+			for (j = 0; j < LIMA_VM_NUM_PT_PER_BT; j++) {
+				pd[j] = pts | LIMA_VM_FLAG_PRESENT;
+				pts += LIMA_PAGE_SIZE;
 			}
-			memset(bt, 0, LIMA_PAGE_SIZE << LIMA_VM_NUM_PT_PER_BT_SHIFT);
-
-			vm->bts[pbe] = bt_bo;
-			pd = lima_bo_kmap(vm->pd);
-			pd += pbe << LIMA_VM_NUM_PT_PER_BT_SHIFT;
-			pts = lima_bo_get_pages(bt_bo);
-			for (j = 0; j < LIMA_VM_NUM_PT_PER_BT; j++)
-				*pd++ = *pts++ | LIMA_VM_FLAG_PRESENT;
 		}
 
-		bt[bte] = dma[i++] | LIMA_VM_FLAGS_CACHE;
+		vm->bts[pbe].cpu[bte] = dma[i++] | LIMA_VM_FLAGS_CACHE;
 	}
 
 	return 0;
-
-err_out:
-	if (addr != start)
-		lima_vm_unmap_page_table(vm, start, addr - 1);
-	return err;
 }
 
 static struct lima_bo_va *
@@ -133,161 +97,123 @@ lima_vm_bo_find(struct lima_vm *vm, struct lima_bo *bo)
 	return ret;
 }
 
-int lima_vm_bo_map(struct lima_vm *vm, struct lima_bo *bo, u32 start)
+int lima_vm_bo_add(struct lima_vm *vm, struct lima_bo *bo, bool create)
 {
-	int err;
-	struct lima_bo_va_mapping *it, *mapping;
-	u32 end = start + bo->gem.size - 1;
-	dma_addr_t *pages_dma = lima_bo_get_pages(bo);
 	struct lima_bo_va *bo_va;
+	int err;
 
-	it = lima_vm_it_iter_first(&vm->va, start, end);
-	if (it) {
-		dev_dbg(bo->gem.dev->dev, "lima vm map va overlap %x-%x %x-%x\n",
-			start, end, it->start, it->last);
-		return -EINVAL;
-	}
-
-	mapping = kmalloc(sizeof(*mapping), GFP_KERNEL);
-	if (!mapping)
-		return -ENOMEM;
-	mapping->start = start;
-	mapping->last = end;
+	mutex_lock(&bo->lock);
 
-	err = lima_vm_map_page_table(vm, pages_dma, start, end);
-	if (err) {
-		kfree(mapping);
-		return err;
+	bo_va = lima_vm_bo_find(vm, bo);
+	if (bo_va) {
+		bo_va->ref_count++;
+		mutex_unlock(&bo->lock);
+		return 0;
 	}
 
-	lima_vm_it_insert(mapping, &vm->va);
+	/* should not create new bo_va if not asked by caller */
+	if (!create) {
+		mutex_unlock(&bo->lock);
+		return -ENOENT;
+	}
 
-	bo_va = lima_vm_bo_find(vm, bo);
-	list_add_tail(&mapping->list, &bo_va->mapping);
+	bo_va = kzalloc(sizeof(*bo_va), GFP_KERNEL);
+	if (!bo_va) {
+		err = -ENOMEM;
+		goto err_out0;
+	}
 
-	return 0;
-}
+	bo_va->vm = vm;
+	bo_va->ref_count = 1;
 
-static void lima_vm_unmap(struct lima_vm *vm,
-			  struct lima_bo_va_mapping *mapping)
-{
-	lima_vm_it_remove(mapping, &vm->va);
+	mutex_lock(&vm->lock);
 
-	lima_vm_unmap_page_table(vm, mapping->start, mapping->last);
+	err = drm_mm_insert_node(&vm->mm, &bo_va->node, bo->gem.size);
+	if (err)
+		goto err_out1;
 
-	list_del(&mapping->list);
-	kfree(mapping);
-}
+	err = lima_vm_map_page_table(vm, bo->pages_dma_addr, bo_va->node.start,
+				     bo_va->node.start + bo_va->node.size - 1);
+	if (err)
+		goto err_out2;
 
-int lima_vm_bo_unmap(struct lima_vm *vm, struct lima_bo *bo, u32 start)
-{
-	struct lima_bo_va *bo_va;
-	struct lima_bo_va_mapping *mapping;
+	mutex_unlock(&vm->lock);
 
-	bo_va = lima_vm_bo_find(vm, bo);
-	list_for_each_entry(mapping, &bo_va->mapping, list) {
-		if (mapping->start == start) {
-		        lima_vm_unmap(vm, mapping);
-			break;
-		}
-	}
+	list_add_tail(&bo_va->list, &bo->va);
 
+	mutex_unlock(&bo->lock);
 	return 0;
+
+err_out2:
+	drm_mm_remove_node(&bo_va->node);
+err_out1:
+	mutex_unlock(&vm->lock);
+	kfree(bo_va);
+err_out0:
+	mutex_unlock(&bo->lock);
+	return err;
 }
 
-int lima_vm_bo_add(struct lima_vm *vm, struct lima_bo *bo)
+void lima_vm_bo_del(struct lima_vm *vm, struct lima_bo *bo)
 {
 	struct lima_bo_va *bo_va;
 
+	mutex_lock(&bo->lock);
+
 	bo_va = lima_vm_bo_find(vm, bo);
-	if (bo_va) {
-		bo_va->ref_count++;
-		return 0;
+	if (--bo_va->ref_count > 0) {
+		mutex_unlock(&bo->lock);
+		return;
 	}
 
-	bo_va = kmalloc(sizeof(*bo_va), GFP_KERNEL);
-	if (!bo_va)
-		return -ENOMEM;
+	mutex_lock(&vm->lock);
 
-	bo_va->vm = vm;
-	bo_va->ref_count = 1;
-	INIT_LIST_HEAD(&bo_va->mapping);
-	list_add_tail(&bo_va->list, &bo->va);
-	return 0;
-}
+	lima_vm_unmap_page_table(vm, bo_va->node.start,
+				 bo_va->node.start + bo_va->node.size - 1);
 
-/* wait only fence of resv from task using vm */
-static int lima_vm_wait_resv(struct lima_vm *vm,
-			     struct reservation_object *resv)
-{
-	unsigned nr_fences;
-	struct dma_fence **fences;
-	int i;
-	long err;
+	drm_mm_remove_node(&bo_va->node);
 
-	err = reservation_object_get_fences_rcu(resv, NULL, &nr_fences, &fences);
-	if (err || !nr_fences)
-		return err;
+	mutex_unlock(&vm->lock);
 
-	for (i = 0; i < nr_fences; i++) {
-		struct drm_sched_fence *sf = to_drm_sched_fence(fences[i]);
-		if (sf && sf->owner == vm)
-			err |= dma_fence_wait(fences[i], false);
-		dma_fence_put(fences[i]);
-	}
+	list_del(&bo_va->list);
 
-	kfree(fences);
-	return err;
+	mutex_unlock(&bo->lock);
+
+	kfree(bo_va);
 }
 
-int lima_vm_bo_del(struct lima_vm *vm, struct lima_bo *bo)
+u32 lima_vm_get_va(struct lima_vm *vm, struct lima_bo *bo)
 {
 	struct lima_bo_va *bo_va;
-	struct lima_bo_va_mapping *mapping, *tmp;
-	int err;
+	u32 ret;
+
+	mutex_lock(&bo->lock);
 
 	bo_va = lima_vm_bo_find(vm, bo);
-	if (--bo_va->ref_count > 0)
-		return 0;
+	ret = bo_va->node.start;
 
-	/* wait bo idle before unmap it from vm in case user
-	 * space application is terminated when bo is busy.
-	 */
-	err = lima_vm_wait_resv(vm, bo->tbo.resv);
-	if (err)
-		dev_err(vm->dev->dev, "bo del fail to wait (%d)\n", err);
+	mutex_unlock(&bo->lock);
 
-	list_for_each_entry_safe(mapping, tmp, &bo_va->mapping, list) {
-	        lima_vm_unmap(vm, mapping);
-	}
-	list_del(&bo_va->list);
-	kfree(bo_va);
-	return 0;
+	return ret;
 }
 
 struct lima_vm *lima_vm_create(struct lima_device *dev)
 {
 	struct lima_vm *vm;
-	void *pd;
 
 	vm = kzalloc(sizeof(*vm), GFP_KERNEL);
 	if (!vm)
 		return NULL;
 
 	vm->dev = dev;
-	vm->va = RB_ROOT_CACHED;
+	mutex_init(&vm->lock);
 	kref_init(&vm->refcount);
 
-	vm->pd = lima_bo_create(dev, LIMA_PAGE_SIZE, 0,
-				ttm_bo_type_kernel, NULL, NULL);
-	if (IS_ERR(vm->pd))
+	vm->pd.cpu = dma_alloc_wc(dev->dev, LIMA_PAGE_SIZE, &vm->pd.dma,
+				  GFP_KERNEL | __GFP_ZERO);
+	if (!vm->pd.cpu)
 		goto err_out0;
 
-	pd = lima_bo_kmap(vm->pd);
-	if (IS_ERR(pd))
-		goto err_out1;
-	memset(pd, 0, LIMA_PAGE_SIZE);
-
 	if (dev->dlbu_cpu) {
 		int err = lima_vm_map_page_table(
 			vm, &dev->dlbu_dma, LIMA_VA_RESERVE_DLBU,
@@ -296,10 +222,12 @@ struct lima_vm *lima_vm_create(struct lima_device *dev)
 			goto err_out1;
 	}
 
+	drm_mm_init(&vm->mm, dev->va_start, dev->va_end - dev->va_start);
+
 	return vm;
 
 err_out1:
-	lima_bo_unref(vm->pd);
+	dma_free_wc(dev->dev, LIMA_PAGE_SIZE, vm->pd.cpu, vm->pd.dma);
 err_out0:
 	kfree(vm);
 	return NULL;
@@ -308,20 +236,18 @@ struct lima_vm *lima_vm_create(struct lima_device *dev)
 void lima_vm_release(struct kref *kref)
 {
 	struct lima_vm *vm = container_of(kref, struct lima_vm, refcount);
-	struct lima_device *dev = vm->dev;
 	int i;
 
-	if (!RB_EMPTY_ROOT(&vm->va.rb_root)) {
-		dev_err(dev->dev, "still active bo inside vm\n");
-	}
+	drm_mm_takedown(&vm->mm);
 
 	for (i = 0; i < LIMA_VM_NUM_BT; i++) {
-		if (vm->bts[i])
-			lima_bo_unref(vm->bts[i]);
+		if (vm->bts[i].cpu)
+			dma_free_wc(vm->dev->dev, LIMA_PAGE_SIZE << LIMA_VM_NUM_PT_PER_BT_SHIFT,
+				    vm->bts[i].cpu, vm->bts[i].dma);
 	}
 
-	if (vm->pd)
-	        lima_bo_unref(vm->pd);
+	if (vm->pd.cpu)
+		dma_free_wc(vm->dev->dev, LIMA_PAGE_SIZE, vm->pd.cpu, vm->pd.dma);
 
 	kfree(vm);
 }
@@ -331,21 +257,23 @@ void lima_vm_print(struct lima_vm *vm)
 	int i, j, k;
 	u32 *pd, *pt;
 
-	/* to avoid the defined by not used warning */
-	(void)&lima_vm_it_iter_next;
+	if (!vm->pd.cpu)
+		return;
 
-	pd = lima_bo_kmap(vm->pd);
+	pd = vm->pd.cpu;
 	for (i = 0; i < LIMA_VM_NUM_BT; i++) {
-		if (!vm->bts[i])
+		if (!vm->bts[i].cpu)
 			continue;
 
-		pt = lima_bo_kmap(vm->bts[i]);
+		pt = vm->bts[i].cpu;
 		for (j = 0; j < LIMA_VM_NUM_PT_PER_BT; j++) {
 			int idx = (i << LIMA_VM_NUM_PT_PER_BT_SHIFT) + j;
+
 			printk(KERN_INFO "lima vm pd %03x:%08x\n", idx, pd[idx]);
 
 			for (k = 0; k < LIMA_PAGE_ENT_NUM; k++) {
 				u32 pte = *pt++;
+
 				if (pte)
 					printk(KERN_INFO "  pt %03x:%08x\n", k, pte);
 			}
diff --git a/drivers/gpu/drm/lima/lima_vm.h b/drivers/gpu/drm/lima/lima_vm.h
index f615f8dfe..caee2f8a2 100644
--- a/drivers/gpu/drm/lima/lima_vm.h
+++ b/drivers/gpu/drm/lima/lima_vm.h
@@ -1,10 +1,10 @@
 /* SPDX-License-Identifier: GPL-2.0 OR MIT */
-/* Copyright 2017-2018 Qiang Yu <yuq825@gmail.com> */
+/* Copyright 2017-2019 Qiang Yu <yuq825@gmail.com> */
 
 #ifndef __LIMA_VM_H__
 #define __LIMA_VM_H__
 
-#include <linux/rbtree.h>
+#include <drm/drm_mm.h>
 #include <linux/kref.h>
 
 #define LIMA_PAGE_SIZE    4096
@@ -19,26 +19,29 @@
 #define LIMA_VA_RESERVE_DLBU   LIMA_VA_RESERVE_START
 #define LIMA_VA_RESERVE_END    0x100000000
 
-struct lima_bo;
 struct lima_device;
 
+struct lima_vm_page {
+	u32 *cpu;
+	dma_addr_t dma;
+};
+
 struct lima_vm {
+	struct mutex lock;
 	struct kref refcount;
 
-	/* tree of virtual addresses mapped */
-	struct rb_root_cached va;
+	struct drm_mm mm;
 
 	struct lima_device *dev;
 
-	struct lima_bo *pd;
-	struct lima_bo *bts[LIMA_VM_NUM_BT];
+	struct lima_vm_page pd;
+	struct lima_vm_page bts[LIMA_VM_NUM_BT];
 };
 
-int lima_vm_bo_map(struct lima_vm *vm, struct lima_bo *bo, u32 start);
-int lima_vm_bo_unmap(struct lima_vm *vm, struct lima_bo *bo, u32 start);
+int lima_vm_bo_add(struct lima_vm *vm, struct lima_bo *bo, bool create);
+void lima_vm_bo_del(struct lima_vm *vm, struct lima_bo *bo);
 
-int lima_vm_bo_add(struct lima_vm *vm, struct lima_bo *bo);
-int lima_vm_bo_del(struct lima_vm *vm, struct lima_bo *bo);
+u32 lima_vm_get_va(struct lima_vm *vm, struct lima_bo *bo);
 
 struct lima_vm *lima_vm_create(struct lima_device *dev);
 void lima_vm_release(struct kref *kref);
