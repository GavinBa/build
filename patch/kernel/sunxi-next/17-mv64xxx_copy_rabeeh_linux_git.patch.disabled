diff --git a/drivers/i2c/busses/i2c-mv64xxx.c b/drivers/i2c/busses/i2c-mv64xxx.c
index 4739e75d1..d22134e67 100644
--- a/drivers/i2c/busses/i2c-mv64xxx.c
+++ b/drivers/i2c/busses/i2c-mv64xxx.c
@@ -15,27 +15,31 @@
 #include <linux/spinlock.h>
 #include <linux/i2c.h>
 #include <linux/interrupt.h>
+#include <linux/delay.h>
 #include <linux/mv643xx_i2c.h>
 #include <linux/platform_device.h>
-#include <linux/reset.h>
 #include <linux/io.h>
 #include <linux/of.h>
-#include <linux/of_device.h>
 #include <linux/of_irq.h>
+#include <linux/of_i2c.h>
 #include <linux/clk.h>
 #include <linux/err.h>
-#include <linux/delay.h>
-
-#define MV64XXX_I2C_ADDR_ADDR(val)			((val & 0x7f) << 1)
-#define MV64XXX_I2C_BAUD_DIV_N(val)			(val & 0x7)
-#define MV64XXX_I2C_BAUD_DIV_M(val)			((val & 0xf) << 3)
 
-#define	MV64XXX_I2C_REG_CONTROL_ACK			BIT(2)
-#define	MV64XXX_I2C_REG_CONTROL_IFLG			BIT(3)
-#define	MV64XXX_I2C_REG_CONTROL_STOP			BIT(4)
-#define	MV64XXX_I2C_REG_CONTROL_START			BIT(5)
-#define	MV64XXX_I2C_REG_CONTROL_TWSIEN			BIT(6)
-#define	MV64XXX_I2C_REG_CONTROL_INTEN			BIT(7)
+/* Register defines */
+#define	MV64XXX_I2C_REG_SLAVE_ADDR			0x00
+#define	MV64XXX_I2C_REG_DATA				0x04
+#define	MV64XXX_I2C_REG_CONTROL				0x08
+#define	MV64XXX_I2C_REG_STATUS				0x0c
+#define	MV64XXX_I2C_REG_BAUD				0x0c
+#define	MV64XXX_I2C_REG_EXT_SLAVE_ADDR			0x10
+#define	MV64XXX_I2C_REG_SOFT_RESET			0x1c
+
+#define	MV64XXX_I2C_REG_CONTROL_ACK			0x00000004
+#define	MV64XXX_I2C_REG_CONTROL_IFLG			0x00000008
+#define	MV64XXX_I2C_REG_CONTROL_STOP			0x00000010
+#define	MV64XXX_I2C_REG_CONTROL_START			0x00000020
+#define	MV64XXX_I2C_REG_CONTROL_TWSIEN			0x00000040
+#define	MV64XXX_I2C_REG_CONTROL_INTEN			0x00000080
 
 /* Ctlr status values */
 #define	MV64XXX_I2C_STATUS_BUS_ERR			0x00
@@ -56,84 +60,41 @@
 #define	MV64XXX_I2C_STATUS_MAST_RD_ADDR_2_NO_ACK	0xe8
 #define	MV64XXX_I2C_STATUS_NO_STATUS			0xf8
 
-/* Register defines (I2C bridge) */
-#define	MV64XXX_I2C_REG_TX_DATA_LO			0xc0
-#define	MV64XXX_I2C_REG_TX_DATA_HI			0xc4
-#define	MV64XXX_I2C_REG_RX_DATA_LO			0xc8
-#define	MV64XXX_I2C_REG_RX_DATA_HI			0xcc
-#define	MV64XXX_I2C_REG_BRIDGE_CONTROL			0xd0
-#define	MV64XXX_I2C_REG_BRIDGE_STATUS			0xd4
-#define	MV64XXX_I2C_REG_BRIDGE_INTR_CAUSE		0xd8
-#define	MV64XXX_I2C_REG_BRIDGE_INTR_MASK		0xdC
-#define	MV64XXX_I2C_REG_BRIDGE_TIMING			0xe0
-
-/* Bridge Control values */
-#define	MV64XXX_I2C_BRIDGE_CONTROL_WR			BIT(0)
-#define	MV64XXX_I2C_BRIDGE_CONTROL_RD			BIT(1)
-#define	MV64XXX_I2C_BRIDGE_CONTROL_ADDR_SHIFT		2
-#define	MV64XXX_I2C_BRIDGE_CONTROL_ADDR_EXT		BIT(12)
-#define	MV64XXX_I2C_BRIDGE_CONTROL_TX_SIZE_SHIFT	13
-#define	MV64XXX_I2C_BRIDGE_CONTROL_RX_SIZE_SHIFT	16
-#define	MV64XXX_I2C_BRIDGE_CONTROL_ENABLE		BIT(19)
-#define	MV64XXX_I2C_BRIDGE_CONTROL_REPEATED_START	BIT(20)
-
-/* Bridge Status values */
-#define	MV64XXX_I2C_BRIDGE_STATUS_ERROR			BIT(0)
-
-/* sun4i TWI LCR register */
-#define	SUN4I_I2C_LCR_REG				0x20
-#define SUN4I_I2C_LCR_SCL_STATE				BIT(5)
-#define SUN4I_I2C_LCR_SDA_STATE				BIT(4)
-#define SUN4I_I2C_LCR_SCL_CTL				BIT(3)
-#define SUN4I_I2C_LCR_SCL_CTL_EN			BIT(2)
-#define SUN4I_I2C_LCR_SDA_CTL				BIT(1)
-#define SUN4I_I2C_LCR_SDA_CTL_EN			BIT(0)
-
 /* Driver states */
 enum {
 	MV64XXX_I2C_STATE_INVALID,
 	MV64XXX_I2C_STATE_IDLE,
 	MV64XXX_I2C_STATE_WAITING_FOR_START_COND,
-	MV64XXX_I2C_STATE_WAITING_FOR_RESTART,
 	MV64XXX_I2C_STATE_WAITING_FOR_ADDR_1_ACK,
 	MV64XXX_I2C_STATE_WAITING_FOR_ADDR_2_ACK,
 	MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_ACK,
 	MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_DATA,
+	MV64XXX_I2C_STATE_WAITING_FOR_REPEATED_START,
 };
 
 /* Driver actions */
 enum {
 	MV64XXX_I2C_ACTION_INVALID,
 	MV64XXX_I2C_ACTION_CONTINUE,
-	MV64XXX_I2C_ACTION_SEND_RESTART,
+	MV64XXX_I2C_ACTION_SEND_START,
 	MV64XXX_I2C_ACTION_SEND_ADDR_1,
 	MV64XXX_I2C_ACTION_SEND_ADDR_2,
 	MV64XXX_I2C_ACTION_SEND_DATA,
 	MV64XXX_I2C_ACTION_RCV_DATA,
 	MV64XXX_I2C_ACTION_RCV_DATA_STOP,
 	MV64XXX_I2C_ACTION_SEND_STOP,
-};
-
-struct mv64xxx_i2c_regs {
-	u8	addr;
-	u8	ext_addr;
-	u8	data;
-	u8	control;
-	u8	status;
-	u8	clock;
-	u8	soft_reset;
+	MV64XXX_I2C_ACTION_NO_STOP,
 };
 
 struct mv64xxx_i2c_data {
-	struct i2c_msg		*msgs;
-	int			num_msgs;
 	int			irq;
 	u32			state;
 	u32			action;
 	u32			aborting;
 	u32			cntl_bits;
 	void __iomem		*reg_base;
-	struct mv64xxx_i2c_regs	reg_offsets;
+	u32			reg_base_p;
+	u32			reg_size;
 	u32			addr1;
 	u32			addr2;
 	u32			bytes_left;
@@ -143,152 +104,19 @@ struct mv64xxx_i2c_data {
 	int			rc;
 	u32			freq_m;
 	u32			freq_n;
+	u32			delay_after_stop;
+	int			irq_disabled;
+#if defined(CONFIG_HAVE_CLK)
 	struct clk              *clk;
-	struct clk              *reg_clk;
+#endif
 	wait_queue_head_t	waitq;
 	spinlock_t		lock;
+	struct device		*dev;
 	struct i2c_msg		*msg;
 	struct i2c_adapter	adapter;
-	bool			offload_enabled;
-/* 5us delay in order to avoid repeated start timing violation */
-	bool			errata_delay;
-	struct reset_control	*rstc;
-	bool			irq_clear_inverted;
-	/* Clk div is 2 to the power n, not 2 to the power n + 1 */
-	bool			clk_n_base_0;
-};
-
-static struct mv64xxx_i2c_regs mv64xxx_i2c_regs_mv64xxx = {
-	.addr		= 0x00,
-	.ext_addr	= 0x10,
-	.data		= 0x04,
-	.control	= 0x08,
-	.status		= 0x0c,
-	.clock		= 0x0c,
-	.soft_reset	= 0x1c,
-};
-
-static struct mv64xxx_i2c_regs mv64xxx_i2c_regs_sun4i = {
-	.addr		= 0x00,
-	.ext_addr	= 0x04,
-	.data		= 0x08,
-	.control	= 0x0c,
-	.status		= 0x10,
-	.clock		= 0x14,
-	.soft_reset	= 0x18,
+	u32			combine_access;
 };
 
-static void sun4i_i2c_set_scl(struct i2c_adapter *adap, int val)
-{
-	struct mv64xxx_i2c_data *drv_data = i2c_get_adapdata(adap);
-        if (val)
-		writel(SUN4I_I2C_LCR_SCL_CTL | SUN4I_I2C_LCR_SCL_CTL_EN,
-		       drv_data->reg_base + SUN4I_I2C_LCR_REG);
-        else
-		writel(SUN4I_I2C_LCR_SCL_CTL_EN, /* write a 0 out of SCL */
-		       drv_data->reg_base + SUN4I_I2C_LCR_REG);
-}
-
-static int sun4i_i2c_get_scl(struct i2c_adapter *adap)
-{
-	struct mv64xxx_i2c_data *drv_data = i2c_get_adapdata(adap);
-        int val;
-
-        /* read the state of SCL */
-	val = readl(drv_data->reg_base + SUN4I_I2C_LCR_REG);
-        return val & SUN4I_I2C_LCR_SCL_STATE;
-}
-
-static void sun4i_i2c_set_sda(struct i2c_adapter *adap, int val)
-{
-	struct mv64xxx_i2c_data *drv_data = i2c_get_adapdata(adap);
-			if (val)
-		writel(SUN4I_I2C_LCR_SDA_CTL | SUN4I_I2C_LCR_SDA_CTL_EN,
-						drv_data->reg_base + SUN4I_I2C_LCR_REG);
-			else
-		writel(SUN4I_I2C_LCR_SDA_CTL_EN, /* write a 0 out of SDA */
-						drv_data->reg_base + SUN4I_I2C_LCR_REG);
-}
-
-static int sun4i_i2c_get_sda(struct i2c_adapter *adap)
-{
-	struct mv64xxx_i2c_data *drv_data = i2c_get_adapdata(adap);
-        int val;
-
-        /* read the state of SDA */
-	val = readl(drv_data->reg_base + SUN4I_I2C_LCR_REG);
-        return val & SUN4I_I2C_LCR_SDA_STATE;
-}
-
-static void sun4i_i2c_scl_prepare_recovery(struct i2c_adapter *adap)
-{
-	struct mv64xxx_i2c_data *drv_data = i2c_get_adapdata(adap);
-        int val;
-
-        /* Disable interrupts */
-        //sun4i_i2c_write_reg(dev, DAVINCI_I2C_IMR_REG, 0);
-
-        /* put I2C into reset */
-        //sun4i_i2c_reset_ctrl(dev, 0);
-
-        /* DEBUG read the state of SCL & SDA */
-	val = readl(drv_data->reg_base + SUN4I_I2C_LCR_REG);
-	dev_err(&drv_data->adapter.dev, "mv64xxx: I2C bus recovering, LCR val: 0x%0x, ", val);
-
-        /* SCL output, SDA input */
-        //sun4i_i2c_write_reg(dev, DAVINCI_I2C_DIR_REG, DAVINCI_I2C_DIR_PDIR0);
-
-        /* change to GPIO mode */
-        //sun4i_i2c_write_reg(dev, DAVINCI_I2C_FUNC_REG,
-        //                      DAVINCI_I2C_FUNC_PFUNC0);
-}
-
-static void sun4i_i2c_scl_unprepare_recovery(struct i2c_adapter *adap)
-{
-	struct mv64xxx_i2c_data *drv_data = i2c_get_adapdata(adap);
-        int val;
-
-        /* change back to I2C mode */
-	writel(0, drv_data->reg_base + SUN4I_I2C_LCR_REG);
-
-        /* DEBUG read the state of SCL & SDA */
-	val = readl(drv_data->reg_base + SUN4I_I2C_LCR_REG);
-	dev_err(&drv_data->adapter.dev, "mv64xxx: I2C bus recovered, LCR val: 0x%0x, ", val);
-
-        //sun4i_i2c_unprepare_recovery(adap);
-}
-
-static struct i2c_bus_recovery_info sun4i_i2c_scl_recovery_info = {
-        .recover_bus = i2c_generic_scl_recovery,
-        .set_scl = sun4i_i2c_set_scl,
-        .get_scl = sun4i_i2c_get_scl,
-				.set_sda = sun4i_i2c_set_sda,
-        .get_sda = sun4i_i2c_get_sda,
-        .prepare_recovery = sun4i_i2c_scl_prepare_recovery,
-        .unprepare_recovery = sun4i_i2c_scl_unprepare_recovery,
-};
-
-static void
-mv64xxx_i2c_prepare_for_io(struct mv64xxx_i2c_data *drv_data,
-	struct i2c_msg *msg)
-{
-	u32	dir = 0;
-
-	drv_data->cntl_bits = MV64XXX_I2C_REG_CONTROL_ACK |
-		MV64XXX_I2C_REG_CONTROL_INTEN | MV64XXX_I2C_REG_CONTROL_TWSIEN;
-
-	if (msg->flags & I2C_M_RD)
-		dir = 1;
-
-	if (msg->flags & I2C_M_TEN) {
-		drv_data->addr1 = 0xf0 | (((u32)msg->addr & 0x300) >> 7) | dir;
-		drv_data->addr2 = (u32)msg->addr & 0xff;
-	} else {
-		drv_data->addr1 = MV64XXX_I2C_ADDR_ADDR((u32)msg->addr) | dir;
-		drv_data->addr2 = 0;
-	}
-}
-
 /*
  *****************************************************************************
  *
@@ -297,26 +125,37 @@ mv64xxx_i2c_prepare_for_io(struct mv64xxx_i2c_data *drv_data,
  *****************************************************************************
  */
 
-/* Reset hardware and initialize FSM */
 static void
-mv64xxx_i2c_hw_init(struct mv64xxx_i2c_data *drv_data)
+mv64xxx_i2c_wait_after_stop(struct mv64xxx_i2c_data *drv_data)
 {
-	if (drv_data->offload_enabled) {
-		writel(0, drv_data->reg_base + MV64XXX_I2C_REG_BRIDGE_CONTROL);
-		writel(0, drv_data->reg_base + MV64XXX_I2C_REG_BRIDGE_TIMING);
-		writel(0, drv_data->reg_base +
-			MV64XXX_I2C_REG_BRIDGE_INTR_CAUSE);
-		writel(0, drv_data->reg_base +
-			MV64XXX_I2C_REG_BRIDGE_INTR_MASK);
+	int i = 0;
+
+	udelay(drv_data->delay_after_stop);
+
+	/* wait for the stop bit up to 100 usec more */
+	while (readl(drv_data->reg_base + MV64XXX_I2C_REG_CONTROL) &
+	       MV64XXX_I2C_REG_CONTROL_STOP){
+		udelay(1);
+		if (i++ > 100) {
+			dev_err(drv_data->dev,
+				" I2C bus locked, stop bit not cleared\n");
+			break;
+		}
 	}
 
-	writel(0, drv_data->reg_base + drv_data->reg_offsets.soft_reset);
-	writel(MV64XXX_I2C_BAUD_DIV_M(drv_data->freq_m) | MV64XXX_I2C_BAUD_DIV_N(drv_data->freq_n),
-		drv_data->reg_base + drv_data->reg_offsets.clock);
-	writel(0, drv_data->reg_base + drv_data->reg_offsets.addr);
-	writel(0, drv_data->reg_base + drv_data->reg_offsets.ext_addr);
+}
+/* Reset hardware and initialize FSM */
+static void
+mv64xxx_i2c_hw_init(struct mv64xxx_i2c_data *drv_data)
+{
+	writel(0, drv_data->reg_base + MV64XXX_I2C_REG_SOFT_RESET);
+	writel((((drv_data->freq_m & 0xf) << 3) | (drv_data->freq_n & 0x7)),
+		drv_data->reg_base + MV64XXX_I2C_REG_BAUD);
+	writel(0, drv_data->reg_base + MV64XXX_I2C_REG_SLAVE_ADDR);
+	writel(0, drv_data->reg_base + MV64XXX_I2C_REG_EXT_SLAVE_ADDR);
 	writel(MV64XXX_I2C_REG_CONTROL_TWSIEN | MV64XXX_I2C_REG_CONTROL_STOP,
-		drv_data->reg_base + drv_data->reg_offsets.control);
+		drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
+	mv64xxx_i2c_wait_after_stop(drv_data);
 	drv_data->state = MV64XXX_I2C_STATE_IDLE;
 }
 
@@ -353,18 +192,15 @@ mv64xxx_i2c_fsm(struct mv64xxx_i2c_data *drv_data, u32 status)
 		/* FALLTHRU */
 	case MV64XXX_I2C_STATUS_MAST_WR_ADDR_2_ACK: /* 0xd0 */
 	case MV64XXX_I2C_STATUS_MAST_WR_ACK: /* 0x28 */
-		if ((drv_data->bytes_left == 0)
-				|| (drv_data->aborting
-					&& (drv_data->byte_posn != 0))) {
-			if (drv_data->send_stop || drv_data->aborting) {
-				drv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;
-				drv_data->state = MV64XXX_I2C_STATE_IDLE;
-			} else {
-				drv_data->action =
-					MV64XXX_I2C_ACTION_SEND_RESTART;
-				drv_data->state =
-					MV64XXX_I2C_STATE_WAITING_FOR_RESTART;
-			}
+		if (drv_data->bytes_left == 0) {
+				if ((drv_data->aborting
+				     && (drv_data->byte_posn != 0)) || !drv_data->combine_access) {
+					drv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;
+					drv_data->state = MV64XXX_I2C_STATE_IDLE;
+				} else {
+					drv_data->action = MV64XXX_I2C_ACTION_NO_STOP;
+					drv_data->state = MV64XXX_I2C_STATE_WAITING_FOR_REPEATED_START;
+				}
 		} else {
 			drv_data->action = MV64XXX_I2C_ACTION_SEND_DATA;
 			drv_data->state =
@@ -413,11 +249,11 @@ mv64xxx_i2c_fsm(struct mv64xxx_i2c_data *drv_data, u32 status)
 		/* Doesn't seem to be a device at other end */
 		drv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;
 		drv_data->state = MV64XXX_I2C_STATE_IDLE;
-		drv_data->rc = -ENXIO;
+		drv_data->rc = -ENODEV;
 		break;
 
 	default:
-		dev_err(&drv_data->adapter.dev,
+		dev_err(drv_data->dev,
 			"mv64xxx_i2c_fsm: Ctlr Error -- state: 0x%x, "
 			"status: 0x%x, addr: 0x%x, flags: 0x%x\n",
 			 drv_data->state, status, drv_data->msg->addr,
@@ -428,170 +264,95 @@ mv64xxx_i2c_fsm(struct mv64xxx_i2c_data *drv_data, u32 status)
 	}
 }
 
-static void mv64xxx_i2c_send_start(struct mv64xxx_i2c_data *drv_data)
-{
-	drv_data->msg = drv_data->msgs;
-	drv_data->byte_posn = 0;
-	drv_data->bytes_left = drv_data->msg->len;
-	drv_data->aborting = 0;
-	drv_data->rc = 0;
-
-	mv64xxx_i2c_prepare_for_io(drv_data, drv_data->msgs);
-	writel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_START,
-	       drv_data->reg_base + drv_data->reg_offsets.control);
-}
-
 static void
 mv64xxx_i2c_do_action(struct mv64xxx_i2c_data *drv_data)
 {
+	dev_dbg(drv_data->dev,
+		"do_action:  state: 0x%x,  action: 0x%x\n",
+		drv_data->state, drv_data->action);
 	switch(drv_data->action) {
-	case MV64XXX_I2C_ACTION_SEND_RESTART:
-		/* We should only get here if we have further messages */
-		BUG_ON(drv_data->num_msgs == 0);
-
-		drv_data->msgs++;
-		drv_data->num_msgs--;
-		mv64xxx_i2c_send_start(drv_data);
-
-		if (drv_data->errata_delay)
-			udelay(5);
-
-		/*
-		 * We're never at the start of the message here, and by this
-		 * time it's already too late to do any protocol mangling.
-		 * Thankfully, do not advertise support for that feature.
-		 */
-		drv_data->send_stop = drv_data->num_msgs == 1;
-		break;
-
 	case MV64XXX_I2C_ACTION_CONTINUE:
 		writel(drv_data->cntl_bits,
-			drv_data->reg_base + drv_data->reg_offsets.control);
+			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
+		break;
+
+	case MV64XXX_I2C_ACTION_SEND_START:
+		writel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_START,
+			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
+		if (drv_data->irq_disabled){
+			udelay(3);
+			drv_data->irq_disabled = 0;
+			enable_irq(drv_data->irq);
+		}
 		break;
 
 	case MV64XXX_I2C_ACTION_SEND_ADDR_1:
 		writel(drv_data->addr1,
-			drv_data->reg_base + drv_data->reg_offsets.data);
+			drv_data->reg_base + MV64XXX_I2C_REG_DATA);
 		writel(drv_data->cntl_bits,
-			drv_data->reg_base + drv_data->reg_offsets.control);
+			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
 		break;
 
 	case MV64XXX_I2C_ACTION_SEND_ADDR_2:
 		writel(drv_data->addr2,
-			drv_data->reg_base + drv_data->reg_offsets.data);
+			drv_data->reg_base + MV64XXX_I2C_REG_DATA);
 		writel(drv_data->cntl_bits,
-			drv_data->reg_base + drv_data->reg_offsets.control);
+			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
 		break;
 
 	case MV64XXX_I2C_ACTION_SEND_DATA:
 		writel(drv_data->msg->buf[drv_data->byte_posn++],
-			drv_data->reg_base + drv_data->reg_offsets.data);
+			drv_data->reg_base + MV64XXX_I2C_REG_DATA);
 		writel(drv_data->cntl_bits,
-			drv_data->reg_base + drv_data->reg_offsets.control);
+			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
 		break;
 
 	case MV64XXX_I2C_ACTION_RCV_DATA:
 		drv_data->msg->buf[drv_data->byte_posn++] =
-			readl(drv_data->reg_base + drv_data->reg_offsets.data);
+			readl(drv_data->reg_base + MV64XXX_I2C_REG_DATA);
 		writel(drv_data->cntl_bits,
-			drv_data->reg_base + drv_data->reg_offsets.control);
+			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
 		break;
 
 	case MV64XXX_I2C_ACTION_RCV_DATA_STOP:
 		drv_data->msg->buf[drv_data->byte_posn++] =
-			readl(drv_data->reg_base + drv_data->reg_offsets.data);
+			readl(drv_data->reg_base + MV64XXX_I2C_REG_DATA);
 		drv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_INTEN;
+
 		writel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_STOP,
-			drv_data->reg_base + drv_data->reg_offsets.control);
+		       drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
+		mv64xxx_i2c_wait_after_stop(drv_data);
+		drv_data->block = 0;
+		wake_up(&drv_data->waitq);
+		break;
+	case MV64XXX_I2C_ACTION_NO_STOP:
+		/* can't mask interrupts by clearing the INTEN as this
+		 * triggers the controller to send the data.
+		 */
+		drv_data->irq_disabled = 1;
+		disable_irq_nosync(drv_data->irq);
 		drv_data->block = 0;
-		if (drv_data->errata_delay)
-			udelay(5);
-
 		wake_up(&drv_data->waitq);
 		break;
 
 	case MV64XXX_I2C_ACTION_INVALID:
 	default:
-		dev_err(&drv_data->adapter.dev,
+		dev_err(drv_data->dev,
 			"mv64xxx_i2c_do_action: Invalid action: %d\n",
 			drv_data->action);
 		drv_data->rc = -EIO;
-
 		/* FALLTHRU */
 	case MV64XXX_I2C_ACTION_SEND_STOP:
 		drv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_INTEN;
 		writel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_STOP,
-			drv_data->reg_base + drv_data->reg_offsets.control);
+			drv_data->reg_base + MV64XXX_I2C_REG_CONTROL);
+		mv64xxx_i2c_wait_after_stop(drv_data);
 		drv_data->block = 0;
 		wake_up(&drv_data->waitq);
 		break;
 	}
 }
 
-static void
-mv64xxx_i2c_read_offload_rx_data(struct mv64xxx_i2c_data *drv_data,
-				 struct i2c_msg *msg)
-{
-	u32 buf[2];
-
-	buf[0] = readl(drv_data->reg_base + MV64XXX_I2C_REG_RX_DATA_LO);
-	buf[1] = readl(drv_data->reg_base + MV64XXX_I2C_REG_RX_DATA_HI);
-
-	memcpy(msg->buf, buf, msg->len);
-}
-
-static int
-mv64xxx_i2c_intr_offload(struct mv64xxx_i2c_data *drv_data)
-{
-	u32 cause, status;
-
-	cause = readl(drv_data->reg_base +
-		      MV64XXX_I2C_REG_BRIDGE_INTR_CAUSE);
-	if (!cause)
-		return IRQ_NONE;
-
-	status = readl(drv_data->reg_base +
-		       MV64XXX_I2C_REG_BRIDGE_STATUS);
-
-	if (status & MV64XXX_I2C_BRIDGE_STATUS_ERROR) {
-		drv_data->rc = -EIO;
-		goto out;
-	}
-
-	drv_data->rc = 0;
-
-	/*
-	 * Transaction is a one message read transaction, read data
-	 * for this message.
-	 */
-	if (drv_data->num_msgs == 1 && drv_data->msgs[0].flags & I2C_M_RD) {
-		mv64xxx_i2c_read_offload_rx_data(drv_data, drv_data->msgs);
-		drv_data->msgs++;
-		drv_data->num_msgs--;
-	}
-	/*
-	 * Transaction is a two messages write/read transaction, read
-	 * data for the second (read) message.
-	 */
-	else if (drv_data->num_msgs == 2 &&
-		 !(drv_data->msgs[0].flags & I2C_M_RD) &&
-		 drv_data->msgs[1].flags & I2C_M_RD) {
-		mv64xxx_i2c_read_offload_rx_data(drv_data, drv_data->msgs + 1);
-		drv_data->msgs += 2;
-		drv_data->num_msgs -= 2;
-	}
-
-out:
-	writel(0, drv_data->reg_base +	MV64XXX_I2C_REG_BRIDGE_CONTROL);
-	writel(0, drv_data->reg_base +
-	       MV64XXX_I2C_REG_BRIDGE_INTR_CAUSE);
-	drv_data->block = 0;
-
-	wake_up(&drv_data->waitq);
-
-	return IRQ_HANDLED;
-}
-
 static irqreturn_t
 mv64xxx_i2c_intr(int irq, void *dev_id)
 {
@@ -601,21 +362,17 @@ mv64xxx_i2c_intr(int irq, void *dev_id)
 	irqreturn_t	rc = IRQ_NONE;
 
 	spin_lock_irqsave(&drv_data->lock, flags);
-
-	if (drv_data->offload_enabled)
-		rc = mv64xxx_i2c_intr_offload(drv_data);
-
-	while (readl(drv_data->reg_base + drv_data->reg_offsets.control) &
+	while (readl(drv_data->reg_base + MV64XXX_I2C_REG_CONTROL) &
 						MV64XXX_I2C_REG_CONTROL_IFLG) {
-		status = readl(drv_data->reg_base + drv_data->reg_offsets.status);
+		status = readl(drv_data->reg_base + MV64XXX_I2C_REG_STATUS);
+		dev_dbg(drv_data->dev,
+			"intr:  status: 0x%x, \n", status);
+
 		mv64xxx_i2c_fsm(drv_data, status);
 		mv64xxx_i2c_do_action(drv_data);
-
-		if (drv_data->irq_clear_inverted)
-			writel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_IFLG,
-			       drv_data->reg_base + drv_data->reg_offsets.control);
-
 		rc = IRQ_HANDLED;
+		if (drv_data->state == MV64XXX_I2C_STATE_WAITING_FOR_REPEATED_START)
+			break;
 	}
 	spin_unlock_irqrestore(&drv_data->lock, flags);
 
@@ -629,6 +386,35 @@ mv64xxx_i2c_intr(int irq, void *dev_id)
  *
  *****************************************************************************
  */
+static void
+mv64xxx_i2c_prepare_for_io(struct mv64xxx_i2c_data *drv_data,
+	struct i2c_msg *msg)
+{
+	u32	dir = 0;
+
+	drv_data->msg = msg;
+	drv_data->byte_posn = 0;
+	drv_data->bytes_left = msg->len;
+	drv_data->aborting = 0;
+	drv_data->rc = 0;
+	drv_data->cntl_bits = MV64XXX_I2C_REG_CONTROL_ACK |
+		MV64XXX_I2C_REG_CONTROL_INTEN | MV64XXX_I2C_REG_CONTROL_TWSIEN;
+
+	if (msg->flags & I2C_M_RD)
+		dir = 1;
+
+	if (msg->flags & I2C_M_REV_DIR_ADDR)
+		dir ^= 1;
+
+	if (msg->flags & I2C_M_TEN) {
+		drv_data->addr1 = 0xf0 | (((u32)msg->addr & 0x300) >> 7) | dir;
+		drv_data->addr2 = (u32)msg->addr & 0xff;
+	} else {
+		drv_data->addr1 = ((u32)msg->addr & 0x7f) << 1 | dir;
+		drv_data->addr2 = 0;
+	}
+}
+
 static void
 mv64xxx_i2c_wait_for_completion(struct mv64xxx_i2c_data *drv_data)
 {
@@ -636,7 +422,7 @@ mv64xxx_i2c_wait_for_completion(struct mv64xxx_i2c_data *drv_data)
 	unsigned long	flags;
 	char		abort = 0;
 
-	time_left = wait_event_timeout(drv_data->waitq,
+	time_left = wait_event_interruptible_timeout(drv_data->waitq,
 		!drv_data->block, drv_data->adapter.timeout);
 
 	spin_lock_irqsave(&drv_data->lock, flags);
@@ -654,15 +440,14 @@ mv64xxx_i2c_wait_for_completion(struct mv64xxx_i2c_data *drv_data)
 
 		time_left = wait_event_timeout(drv_data->waitq,
 			!drv_data->block, drv_data->adapter.timeout);
+		drv_data->rc = time_left;
 
 		if ((time_left <= 0) && drv_data->block) {
 			drv_data->state = MV64XXX_I2C_STATE_IDLE;
-			dev_err(&drv_data->adapter.dev,
+			dev_err(drv_data->dev,
 				"mv64xxx: I2C bus locked, block: %d, "
 				"time_left: %d\n", drv_data->block,
 				(int)time_left);
-
-			i2c_recover_bus(&drv_data->adapter);
 			mv64xxx_i2c_hw_init(drv_data);
 		}
 	} else
@@ -670,133 +455,38 @@ mv64xxx_i2c_wait_for_completion(struct mv64xxx_i2c_data *drv_data)
 }
 
 static int
-mv64xxx_i2c_execute_msg(struct mv64xxx_i2c_data *drv_data, struct i2c_msg *msg,
-				int is_last)
+mv64xxx_i2c_execute_msg(struct mv64xxx_i2c_data *drv_data, struct i2c_msg *msg)
 {
 	unsigned long	flags;
 
 	spin_lock_irqsave(&drv_data->lock, flags);
+	mv64xxx_i2c_prepare_for_io(drv_data, msg);
 
-	drv_data->state = MV64XXX_I2C_STATE_WAITING_FOR_START_COND;
-
-	drv_data->send_stop = is_last;
-	drv_data->block = 1;
-	mv64xxx_i2c_send_start(drv_data);
-	spin_unlock_irqrestore(&drv_data->lock, flags);
-
-	mv64xxx_i2c_wait_for_completion(drv_data);
-	return drv_data->rc;
-}
-
-static void
-mv64xxx_i2c_prepare_tx(struct mv64xxx_i2c_data *drv_data)
-{
-	struct i2c_msg *msg = drv_data->msgs;
-	u32 buf[2];
-
-	memcpy(buf, msg->buf, msg->len);
-
-	writel(buf[0], drv_data->reg_base + MV64XXX_I2C_REG_TX_DATA_LO);
-	writel(buf[1], drv_data->reg_base + MV64XXX_I2C_REG_TX_DATA_HI);
-}
-
-static int
-mv64xxx_i2c_offload_xfer(struct mv64xxx_i2c_data *drv_data)
-{
-	struct i2c_msg *msgs = drv_data->msgs;
-	int num = drv_data->num_msgs;
-	unsigned long ctrl_reg;
-	unsigned long flags;
-
-	spin_lock_irqsave(&drv_data->lock, flags);
-
-	/* Build transaction */
-	ctrl_reg = MV64XXX_I2C_BRIDGE_CONTROL_ENABLE |
-		(msgs[0].addr << MV64XXX_I2C_BRIDGE_CONTROL_ADDR_SHIFT);
-
-	if (msgs[0].flags & I2C_M_TEN)
-		ctrl_reg |= MV64XXX_I2C_BRIDGE_CONTROL_ADDR_EXT;
-
-	/* Single write message transaction */
-	if (num == 1 && !(msgs[0].flags & I2C_M_RD)) {
-		size_t len = msgs[0].len - 1;
-
-		ctrl_reg |= MV64XXX_I2C_BRIDGE_CONTROL_WR |
-			(len << MV64XXX_I2C_BRIDGE_CONTROL_TX_SIZE_SHIFT);
-		mv64xxx_i2c_prepare_tx(drv_data);
-	}
-	/* Single read message transaction */
-	else if (num == 1 && msgs[0].flags & I2C_M_RD) {
-		size_t len = msgs[0].len - 1;
-
-		ctrl_reg |= MV64XXX_I2C_BRIDGE_CONTROL_RD |
-			(len << MV64XXX_I2C_BRIDGE_CONTROL_RX_SIZE_SHIFT);
-	}
-	/*
-	 * Transaction with one write and one read message. This is
-	 * guaranteed by the mv64xx_i2c_can_offload() checks.
-	 */
-	else if (num == 2) {
-		size_t lentx = msgs[0].len - 1;
-		size_t lenrx = msgs[1].len - 1;
-
-		ctrl_reg |=
-			MV64XXX_I2C_BRIDGE_CONTROL_RD |
-			MV64XXX_I2C_BRIDGE_CONTROL_WR |
-			(lentx << MV64XXX_I2C_BRIDGE_CONTROL_TX_SIZE_SHIFT) |
-			(lenrx << MV64XXX_I2C_BRIDGE_CONTROL_RX_SIZE_SHIFT) |
-			MV64XXX_I2C_BRIDGE_CONTROL_REPEATED_START;
-		mv64xxx_i2c_prepare_tx(drv_data);
+	if (unlikely(msg->flags & I2C_M_NOSTART)) { /* Skip start/addr phases */
+		if (drv_data->msg->flags & I2C_M_RD) {
+			/* No action to do, wait for slave to send a byte */
+			drv_data->action = MV64XXX_I2C_ACTION_CONTINUE;
+			drv_data->state =
+				MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_DATA;
+		} else {
+			drv_data->action = MV64XXX_I2C_ACTION_SEND_DATA;
+			drv_data->state =
+				MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_ACK;
+			drv_data->bytes_left--;
+		}
+	} else {
+		drv_data->action = MV64XXX_I2C_ACTION_SEND_START;
+		drv_data->state = MV64XXX_I2C_STATE_WAITING_FOR_START_COND;
 	}
 
-	/* Execute transaction */
 	drv_data->block = 1;
-	writel(ctrl_reg, drv_data->reg_base + MV64XXX_I2C_REG_BRIDGE_CONTROL);
+	mv64xxx_i2c_do_action(drv_data);
 	spin_unlock_irqrestore(&drv_data->lock, flags);
 
 	mv64xxx_i2c_wait_for_completion(drv_data);
-
 	return drv_data->rc;
 }
 
-static bool
-mv64xxx_i2c_valid_offload_sz(struct i2c_msg *msg)
-{
-	return msg->len <= 8 && msg->len >= 1;
-}
-
-static bool
-mv64xxx_i2c_can_offload(struct mv64xxx_i2c_data *drv_data)
-{
-	struct i2c_msg *msgs = drv_data->msgs;
-	int num = drv_data->num_msgs;
-
-	if (!drv_data->offload_enabled)
-		return false;
-
-	/*
-	 * We can offload a transaction consisting of a single
-	 * message, as long as the message has a length between 1 and
-	 * 8 bytes.
-	 */
-	if (num == 1 && mv64xxx_i2c_valid_offload_sz(msgs))
-		return true;
-
-	/*
-	 * We can offload a transaction consisting of two messages, if
-	 * the first is a write and a second is a read, and both have
-	 * a length between 1 and 8 bytes.
-	 */
-	if (num == 2 &&
-	    mv64xxx_i2c_valid_offload_sz(msgs) &&
-	    mv64xxx_i2c_valid_offload_sz(msgs + 1) &&
-	    !(msgs[0].flags & I2C_M_RD) &&
-	    msgs[1].flags & I2C_M_RD)
-		return true;
-
-	return false;
-}
-
 /*
  *****************************************************************************
  *
@@ -809,36 +499,38 @@ mv64xxx_i2c_functionality(struct i2c_adapter *adap)
 {
 	return I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR | I2C_FUNC_SMBUS_EMUL;
 }
-
 static int
 mv64xxx_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
 {
 	struct mv64xxx_i2c_data *drv_data = i2c_get_adapdata(adap);
-	int rc, ret = num;
-
-	BUG_ON(drv_data->msgs != NULL);
-	drv_data->msgs = msgs;
-	drv_data->num_msgs = num;
-
-	if (mv64xxx_i2c_can_offload(drv_data))
-		rc = mv64xxx_i2c_offload_xfer(drv_data);
-	else
-		rc = mv64xxx_i2c_execute_msg(drv_data, &msgs[0], num == 1);
-
-	if (rc < 0)
-		ret = rc;
-
-	drv_data->num_msgs = 0;
-	drv_data->msgs = NULL;
-
-	return ret;
+	int	i, rc;
+
+	for (i=0; i<num; i++)
+	{
+		if(num > 1 && (i != num-1))
+                {
+			/*
+			 * if combine access, we don't send stop signal
+			 * between msgs. 
+			 */
+			drv_data->combine_access = 1;
+			dev_dbg(drv_data->dev,
+				"xfer:  combine_access\n");
+
+                }else{
+			drv_data->combine_access = 0;
+                }
+
+		if ((rc = mv64xxx_i2c_execute_msg(drv_data, &msgs[i])) < 0)
+			return rc;
+	}
+	return num;
 }
 
 static const struct i2c_algorithm mv64xxx_i2c_algo = {
 	.master_xfer = mv64xxx_i2c_xfer,
 	.functionality = mv64xxx_i2c_functionality,
 };
-
 /*
  *****************************************************************************
  *
@@ -846,41 +538,61 @@ static const struct i2c_algorithm mv64xxx_i2c_algo = {
  *
  *****************************************************************************
  */
-static const struct of_device_id mv64xxx_i2c_of_match_table[] = {
-	{ .compatible = "allwinner,sun4i-a10-i2c", .data = &mv64xxx_i2c_regs_sun4i},
-	{ .compatible = "allwinner,sun6i-a31-i2c", .data = &mv64xxx_i2c_regs_sun4i},
-	{ .compatible = "marvell,mv64xxx-i2c", .data = &mv64xxx_i2c_regs_mv64xxx},
-	{ .compatible = "marvell,mv78230-i2c", .data = &mv64xxx_i2c_regs_mv64xxx},
-	{ .compatible = "marvell,mv78230-a0-i2c", .data = &mv64xxx_i2c_regs_mv64xxx},
-	{}
-};
-MODULE_DEVICE_TABLE(of, mv64xxx_i2c_of_match_table);
+static int __devinit
+mv64xxx_i2c_map_regs(struct platform_device *pd,
+	struct mv64xxx_i2c_data *drv_data)
+{
+	int size;
+	struct resource	*r = platform_get_resource(pd, IORESOURCE_MEM, 0);
+
+	if (!r)
+		return -ENODEV;
+
+	size = resource_size(r);
+
+	if (!request_mem_region(r->start, size, pd->name))
+		return -EBUSY;
+
+	drv_data->reg_base = ioremap(r->start, size);
+	drv_data->reg_base_p = r->start;
+	drv_data->reg_size = size;
+
+	return 0;
+}
+
+static void
+mv64xxx_i2c_unmap_regs(struct mv64xxx_i2c_data *drv_data)
+{
+	if (drv_data->reg_base) {
+		iounmap(drv_data->reg_base);
+		release_mem_region(drv_data->reg_base_p, drv_data->reg_size);
+	}
+
+	drv_data->reg_base = NULL;
+	drv_data->reg_base_p = 0;
+}
 
 #ifdef CONFIG_OF
-static int
-mv64xxx_calc_freq(struct mv64xxx_i2c_data *drv_data,
-		  const int tclk, const int n, const int m)
+static int __devinit
+mv64xxx_calc_freq(const int tclk, const int n, const int m)
 {
-	if (drv_data->clk_n_base_0)
-		return tclk / (10 * (m + 1) * (1 << n));
-	else
-		return tclk / (10 * (m + 1) * (2 << n));
+	return tclk / (10 * (m + 1) * (2 << n));
 }
 
-static bool
-mv64xxx_find_baud_factors(struct mv64xxx_i2c_data *drv_data,
-			  const u32 req_freq, const u32 tclk)
+static bool __devinit
+mv64xxx_find_baud_factors(const u32 req_freq, const u32 tclk, u32 *best_n,
+			  u32 *best_m)
 {
 	int freq, delta, best_delta = INT_MAX;
 	int m, n;
 
 	for (n = 0; n <= 7; n++)
 		for (m = 0; m <= 15; m++) {
-			freq = mv64xxx_calc_freq(drv_data, tclk, n, m);
+			freq = mv64xxx_calc_freq(tclk, n, m);
 			delta = req_freq - freq;
 			if (delta >= 0 && delta < best_delta) {
-				drv_data->freq_m = m;
-				drv_data->freq_n = n;
+				*best_m = m;
+				*best_n = n;
 				best_delta = delta;
 			}
 			if (best_delta == 0)
@@ -891,12 +603,10 @@ mv64xxx_find_baud_factors(struct mv64xxx_i2c_data *drv_data,
 	return true;
 }
 
-static int
+static int __devinit
 mv64xxx_of_config(struct mv64xxx_i2c_data *drv_data,
-		  struct device *dev)
+		  struct device_node *np)
 {
-	const struct of_device_id *device;
-	struct device_node *np = dev->of_node;
 	u32 bus_freq, tclk;
 	int rc = 0;
 
@@ -904,95 +614,57 @@ mv64xxx_of_config(struct mv64xxx_i2c_data *drv_data,
 	 * need to know tclk in order to calculate bus clock
 	 * factors.
 	 */
+#if !defined(CONFIG_HAVE_CLK)
+	/* Have OF but no CLK */
+	return -ENODEV;
+#else
 	if (IS_ERR(drv_data->clk)) {
 		rc = -ENODEV;
 		goto out;
 	}
 	tclk = clk_get_rate(drv_data->clk);
-
-	if (of_property_read_u32(np, "clock-frequency", &bus_freq))
-		bus_freq = 100000; /* 100kHz by default */
-
-	if (of_device_is_compatible(np, "allwinner,sun4i-a10-i2c") ||
-	    of_device_is_compatible(np, "allwinner,sun6i-a31-i2c"))
-		drv_data->clk_n_base_0 = true;
-
-	if (!mv64xxx_find_baud_factors(drv_data, bus_freq, tclk)) {
+	of_property_read_u32(np, "clock-frequency", &bus_freq);
+	if (!mv64xxx_find_baud_factors(bus_freq, tclk,
+				       &drv_data->freq_n, &drv_data->freq_m)) {
 		rc = -EINVAL;
 		goto out;
 	}
-
-	drv_data->rstc = devm_reset_control_get_optional_exclusive(dev, NULL);
-	if (IS_ERR(drv_data->rstc)) {
-		rc = PTR_ERR(drv_data->rstc);
-		goto out;
-	}
-	reset_control_deassert(drv_data->rstc);
+	drv_data->irq = irq_of_parse_and_map(np, 0);
 
 	/* Its not yet defined how timeouts will be specified in device tree.
 	 * So hard code the value to 1 second.
 	 */
 	drv_data->adapter.timeout = HZ;
-
-	device = of_match_device(mv64xxx_i2c_of_match_table, dev);
-	if (!device)
-		return -ENODEV;
-
-	memcpy(&drv_data->reg_offsets, device->data, sizeof(drv_data->reg_offsets));
-
-	/*
-	 * For controllers embedded in new SoCs activate the
-	 * Transaction Generator support and the errata fix.
-	 */
-	if (of_device_is_compatible(np, "marvell,mv78230-i2c")) {
-		drv_data->offload_enabled = true;
-		/* The delay is only needed in standard mode (100kHz) */
-		if (bus_freq <= 100000)
-			drv_data->errata_delay = true;
-	}
-
-	if (of_device_is_compatible(np, "marvell,mv78230-a0-i2c")) {
-		drv_data->offload_enabled = false;
-		/* The delay is only needed in standard mode (100kHz) */
-		if (bus_freq <= 100000)
-			drv_data->errata_delay = true;
-	}
-
-	if (of_device_is_compatible(np, "allwinner,sun6i-a31-i2c"))
-		drv_data->irq_clear_inverted = true;
-
 out:
 	return rc;
+#endif
 }
 #else /* CONFIG_OF */
-static int
+static int __devinit
 mv64xxx_of_config(struct mv64xxx_i2c_data *drv_data,
-		  struct device *dev)
+		  struct device_node *np)
 {
 	return -ENODEV;
 }
 #endif /* CONFIG_OF */
 
-static int
+static int __devinit
 mv64xxx_i2c_probe(struct platform_device *pd)
 {
 	struct mv64xxx_i2c_data		*drv_data;
-	struct mv64xxx_i2c_pdata	*pdata = dev_get_platdata(&pd->dev);
-	struct resource	*r;
+	struct mv64xxx_i2c_pdata	*pdata = pd->dev.platform_data;
 	int	rc;
 
 	if ((!pdata && !pd->dev.of_node))
 		return -ENODEV;
 
-	drv_data = devm_kzalloc(&pd->dev, sizeof(struct mv64xxx_i2c_data),
-				GFP_KERNEL);
+	drv_data = kzalloc(sizeof(struct mv64xxx_i2c_data), GFP_KERNEL);
 	if (!drv_data)
 		return -ENOMEM;
-
-	r = platform_get_resource(pd, IORESOURCE_MEM, 0);
-	drv_data->reg_base = devm_ioremap_resource(&pd->dev, r);
-	if (IS_ERR(drv_data->reg_base))
-		return PTR_ERR(drv_data->reg_base);
+	if (mv64xxx_i2c_map_regs(pd, drv_data)) {
+		rc = -ENODEV;
+		goto exit_kfree;
+	}
 
 	strlcpy(drv_data->adapter.name, MV64XXX_I2C_CTLR_NAME " adapter",
 		sizeof(drv_data->adapter.name));
@@ -1000,121 +672,127 @@ mv64xxx_i2c_probe(struct platform_device *pd)
 	init_waitqueue_head(&drv_data->waitq);
 	spin_lock_init(&drv_data->lock);
 
-	/* Not all platforms have clocks */
-	drv_data->clk = devm_clk_get(&pd->dev, NULL);
-	if (IS_ERR(drv_data->clk) && PTR_ERR(drv_data->clk) == -EPROBE_DEFER)
-		return -EPROBE_DEFER;
-	if (!IS_ERR(drv_data->clk))
-		clk_prepare_enable(drv_data->clk);
-
-	drv_data->reg_clk = devm_clk_get(&pd->dev, "reg");
-	if (IS_ERR(drv_data->reg_clk) &&
-	    PTR_ERR(drv_data->reg_clk) == -EPROBE_DEFER)
-		return -EPROBE_DEFER;
-	if (!IS_ERR(drv_data->reg_clk))
-		clk_prepare_enable(drv_data->reg_clk);
-
-	drv_data->irq = platform_get_irq(pd, 0);
-
+#if defined(CONFIG_HAVE_CLK)
+	/* Not all platforms have a clk */
+	drv_data->clk = clk_get(&pd->dev, NULL);
+	if (!IS_ERR(drv_data->clk)) {
+		clk_prepare(drv_data->clk);
+		clk_enable(drv_data->clk);
+	}
+#endif
 	if (pdata) {
 		drv_data->freq_m = pdata->freq_m;
 		drv_data->freq_n = pdata->freq_n;
 		drv_data->irq = platform_get_irq(pd, 0);
 		drv_data->adapter.timeout = msecs_to_jiffies(pdata->timeout);
-		drv_data->offload_enabled = false;
-		memcpy(&drv_data->reg_offsets, &mv64xxx_i2c_regs_mv64xxx, sizeof(drv_data->reg_offsets));
+		drv_data->delay_after_stop = pdata->delay_after_stop ?
+			pdata->delay_after_stop : 1;
+
 	} else if (pd->dev.of_node) {
-		rc = mv64xxx_of_config(drv_data, &pd->dev);
+		rc = mv64xxx_of_config(drv_data, pd->dev.of_node);
 		if (rc)
-			goto exit_clk;
+			goto exit_unmap_regs;
 	}
 	if (drv_data->irq < 0) {
-		rc = drv_data->irq;
-		goto exit_reset;
+		rc = -ENXIO;
+		goto exit_unmap_regs;
 	}
 
+	drv_data->irq_disabled = 0;
+	drv_data->dev = &pd->dev;
 	drv_data->adapter.dev.parent = &pd->dev;
 	drv_data->adapter.algo = &mv64xxx_i2c_algo;
 	drv_data->adapter.owner = THIS_MODULE;
-	drv_data->adapter.class = I2C_CLASS_DEPRECATED;
+	drv_data->adapter.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;
 	drv_data->adapter.nr = pd->id;
 	drv_data->adapter.dev.of_node = pd->dev.of_node;
-	drv_data->adapter.bus_recovery_info = &sun4i_i2c_scl_recovery_info; // FIXME should be more generic as this driver is shared
 	platform_set_drvdata(pd, drv_data);
 	i2c_set_adapdata(&drv_data->adapter, drv_data);
 
 	mv64xxx_i2c_hw_init(drv_data);
 
-	rc = request_irq(drv_data->irq, mv64xxx_i2c_intr, 0,
-			 MV64XXX_I2C_CTLR_NAME, drv_data);
-	if (rc) {
+	if (request_irq(drv_data->irq, mv64xxx_i2c_intr, 0,
+			MV64XXX_I2C_CTLR_NAME, drv_data)) {
 		dev_err(&drv_data->adapter.dev,
-			"mv64xxx: Can't register intr handler irq%d: %d\n",
-			drv_data->irq, rc);
-		goto exit_reset;
+			"mv64xxx: Can't register intr handler irq: %d\n",
+			drv_data->irq);
+		rc = -EINVAL;
+		goto exit_unmap_regs;
 	} else if ((rc = i2c_add_numbered_adapter(&drv_data->adapter)) != 0) {
 		dev_err(&drv_data->adapter.dev,
 			"mv64xxx: Can't add i2c adapter, rc: %d\n", -rc);
 		goto exit_free_irq;
 	}
 
-	return 0;
+	of_i2c_register_devices(&drv_data->adapter);
 
-exit_free_irq:
-	free_irq(drv_data->irq, drv_data);
-exit_reset:
-	reset_control_assert(drv_data->rstc);
-exit_clk:
-	clk_disable_unprepare(drv_data->reg_clk);
-	clk_disable_unprepare(drv_data->clk);
+	return 0;
 
+	exit_free_irq:
+		free_irq(drv_data->irq, drv_data);
+	exit_unmap_regs:
+#if defined(CONFIG_HAVE_CLK)
+	/* Not all platforms have a clk */
+	if (!IS_ERR(drv_data->clk)) {
+		clk_disable(drv_data->clk);
+		clk_unprepare(drv_data->clk);
+	}
+#endif
+		mv64xxx_i2c_unmap_regs(drv_data);
+	exit_kfree:
+		kfree(drv_data);
 	return rc;
 }
 
-static int
+static int __devexit
 mv64xxx_i2c_remove(struct platform_device *dev)
 {
 	struct mv64xxx_i2c_data		*drv_data = platform_get_drvdata(dev);
+	int	rc = 0;
 
-	i2c_del_adapter(&drv_data->adapter);
 	free_irq(drv_data->irq, drv_data);
-	reset_control_assert(drv_data->rstc);
-	clk_disable_unprepare(drv_data->reg_clk);
-	clk_disable_unprepare(drv_data->clk);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int mv64xxx_i2c_resume(struct device *dev)
-{
-	struct mv64xxx_i2c_data *drv_data = dev_get_drvdata(dev);
-
-	mv64xxx_i2c_hw_init(drv_data);
+	mv64xxx_i2c_unmap_regs(drv_data);
+#if defined(CONFIG_HAVE_CLK)
+	/* Not all platforms have a clk */
+	if (!IS_ERR(drv_data->clk)) {
+		clk_disable(drv_data->clk);
+		clk_unprepare(drv_data->clk);
+	}
+#endif
+	kfree(drv_data);
 
-	return 0;
+	return rc;
 }
 
-static const struct dev_pm_ops mv64xxx_i2c_pm = {
-	.resume = mv64xxx_i2c_resume,
+static const struct of_device_id mv64xxx_i2c_of_match_table[] __devinitdata = {
+	{ .compatible = "marvell,mv64xxx-i2c", },
+	{}
 };
-
-#define mv64xxx_i2c_pm_ops (&mv64xxx_i2c_pm)
-#else
-#define mv64xxx_i2c_pm_ops NULL
-#endif
+MODULE_DEVICE_TABLE(of, mv64xxx_i2c_of_match_table);
 
 static struct platform_driver mv64xxx_i2c_driver = {
 	.probe	= mv64xxx_i2c_probe,
-	.remove	= mv64xxx_i2c_remove,
+	.remove	= __devexit_p(mv64xxx_i2c_remove),
 	.driver	= {
+		.owner	= THIS_MODULE,
 		.name	= MV64XXX_I2C_CTLR_NAME,
-		.pm     = mv64xxx_i2c_pm_ops,
-		.of_match_table = mv64xxx_i2c_of_match_table,
+		.of_match_table = of_match_ptr(mv64xxx_i2c_of_match_table),
 	},
 };
 
-module_platform_driver(mv64xxx_i2c_driver);
+static int __init mv64xxx_i2c_init(void)
+{
+	int rc = platform_driver_register(&mv64xxx_i2c_driver);
+	return rc;
+}
+
+static void __exit mv64xxx_i2c_exit(void)
+{
+	platform_driver_unregister(&mv64xxx_i2c_driver);
+}
+
+module_init(mv64xxx_i2c_init);
+module_exit(mv64xxx_i2c_exit);
 
 MODULE_AUTHOR("Mark A. Greer <mgreer@mvista.com>");
 MODULE_DESCRIPTION("Marvell mv64xxx host bridge i2c ctlr driver");
diff --git a/include/linux/mv643xx_i2c.h b/include/linux/mv643xx_i2c.h
index 5db5152e9..6d151c4dd 100644
--- a/include/linux/mv643xx_i2c.h
+++ b/include/linux/mv643xx_i2c.h
@@ -16,6 +16,7 @@
 struct mv64xxx_i2c_pdata {
 	u32	freq_m;
 	u32	freq_n;
+	u32	delay_after_stop;
 	u32	timeout;	/* In milliseconds */
 };
 
