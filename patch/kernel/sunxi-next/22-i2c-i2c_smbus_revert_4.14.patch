diff --git a/include/linux/i2c-smbus.h b/include/linux/i2c-smbus.h
index fb0e040b1..a1385023a 100644
--- a/include/linux/i2c-smbus.h
+++ b/include/linux/i2c-smbus.h
@@ -42,6 +42,7 @@
  * properly set.
  */
 struct i2c_smbus_alert_setup {
+	unsigned int		alert_edge_triggered:1;
 	int			irq;
 };
 
@@ -49,13 +50,4 @@ struct i2c_client *i2c_setup_smbus_alert(struct i2c_adapter *adapter,
 					 struct i2c_smbus_alert_setup *setup);
 int i2c_handle_smbus_alert(struct i2c_client *ara);
 
-#if IS_ENABLED(CONFIG_I2C_SMBUS) && IS_ENABLED(CONFIG_OF)
-int of_i2c_setup_smbus_alert(struct i2c_adapter *adap);
-#else
-static inline int of_i2c_setup_smbus_alert(struct i2c_adapter *adap)
-{
-	return 0;
-}
-#endif
-
 #endif /* _LINUX_I2C_SMBUS_H */
diff --git a/include/linux/i2c.h b/include/linux/i2c.h
index be27062f8..d501d3956 100644
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@ -47,7 +47,6 @@ struct i2c_algorithm;
 struct i2c_adapter;
 struct i2c_client;
 struct i2c_driver;
-struct i2c_device_identity;
 union i2c_smbus_data;
 struct i2c_board_info;
 enum i2c_slave_event;
@@ -56,7 +55,7 @@ typedef int (*i2c_slave_cb_t)(struct i2c_client *, enum i2c_slave_event, u8 *);
 struct module;
 struct property_entry;
 
-#if IS_ENABLED(CONFIG_I2C)
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
 /*
  * The master routines are the ones normally used to transmit data to devices
  * on a bus (or read from them). Apart from two basic transfer functions to
@@ -64,68 +63,10 @@ struct property_entry;
  * transmit an arbitrary number of messages without interruption.
  * @count must be be less than 64k since msg.len is u16.
  */
-extern int i2c_transfer_buffer_flags(const struct i2c_client *client,
-				     char *buf, int count, u16 flags);
-
-/**
- * i2c_master_recv - issue a single I2C message in master receive mode
- * @client: Handle to slave device
- * @buf: Where to store data read from slave
- * @count: How many bytes to read, must be less than 64k since msg.len is u16
- *
- * Returns negative errno, or else the number of bytes read.
- */
-static inline int i2c_master_recv(const struct i2c_client *client,
-				  char *buf, int count)
-{
-	return i2c_transfer_buffer_flags(client, buf, count, I2C_M_RD);
-};
-
-/**
- * i2c_master_recv_dmasafe - issue a single I2C message in master receive mode
- *			     using a DMA safe buffer
- * @client: Handle to slave device
- * @buf: Where to store data read from slave, must be safe to use with DMA
- * @count: How many bytes to read, must be less than 64k since msg.len is u16
- *
- * Returns negative errno, or else the number of bytes read.
- */
-static inline int i2c_master_recv_dmasafe(const struct i2c_client *client,
-					  char *buf, int count)
-{
-	return i2c_transfer_buffer_flags(client, buf, count,
-					 I2C_M_RD | I2C_M_DMA_SAFE);
-};
-
-/**
- * i2c_master_send - issue a single I2C message in master transmit mode
- * @client: Handle to slave device
- * @buf: Data that will be written to the slave
- * @count: How many bytes to write, must be less than 64k since msg.len is u16
- *
- * Returns negative errno, or else the number of bytes written.
- */
-static inline int i2c_master_send(const struct i2c_client *client,
-				  const char *buf, int count)
-{
-	return i2c_transfer_buffer_flags(client, (char *)buf, count, 0);
-};
-
-/**
- * i2c_master_send_dmasafe - issue a single I2C message in master transmit mode
- *			     using a DMA safe buffer
- * @client: Handle to slave device
- * @buf: Data that will be written to the slave, must be safe to use with DMA
- * @count: How many bytes to write, must be less than 64k since msg.len is u16
- *
- * Returns negative errno, or else the number of bytes written.
- */
-static inline int i2c_master_send_dmasafe(const struct i2c_client *client,
-					  const char *buf, int count)
-{
-	return i2c_transfer_buffer_flags(client, (char *)buf, count,
-					 I2C_M_DMA_SAFE);
-};
+extern int i2c_master_send(const struct i2c_client *client, const char *buf,
+			   int count);
+extern int i2c_master_recv(const struct i2c_client *client, char *buf,
+			   int count);
 
 /* Transfer num messages.
  */
@@ -140,14 +81,9 @@ extern int __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
    and probably just as fast.
    Note that we use i2c_adapter here, because you do not need a specific
    smbus adapter to call this function. */
-s32 i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,
-		   unsigned short flags, char read_write, u8 command,
-		   int protocol, union i2c_smbus_data *data);
-
-/* Unlocked flavor */
-s32 __i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,
-		     unsigned short flags, char read_write, u8 command,
-		     int protocol, union i2c_smbus_data *data);
+extern s32 i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,
+			  unsigned short flags, char read_write, u8 command,
+			  int size, union i2c_smbus_data *data);
 
 /* Now follow the 'nice' access routines. These also document the calling
    conventions of i2c_smbus_xfer. */
@@ -192,37 +128,8 @@ extern s32 i2c_smbus_write_i2c_block_data(const struct i2c_client *client,
 extern s32
 i2c_smbus_read_i2c_block_data_or_emulated(const struct i2c_client *client,
 					  u8 command, u8 length, u8 *values);
-int i2c_get_device_id(const struct i2c_client *client,
-		      struct i2c_device_identity *id);
 #endif /* I2C */
 
-/**
- * struct i2c_device_identity - i2c client device identification
- * @manufacturer_id: 0 - 4095, database maintained by NXP
- * @part_id: 0 - 511, according to manufacturer
- * @die_revision: 0 - 7, according to manufacturer
- */
-struct i2c_device_identity {
-	u16 manufacturer_id;
-#define I2C_DEVICE_ID_NXP_SEMICONDUCTORS                0
-#define I2C_DEVICE_ID_NXP_SEMICONDUCTORS_1              1
-#define I2C_DEVICE_ID_NXP_SEMICONDUCTORS_2              2
-#define I2C_DEVICE_ID_NXP_SEMICONDUCTORS_3              3
-#define I2C_DEVICE_ID_RAMTRON_INTERNATIONAL             4
-#define I2C_DEVICE_ID_ANALOG_DEVICES                    5
-#define I2C_DEVICE_ID_STMICROELECTRONICS                6
-#define I2C_DEVICE_ID_ON_SEMICONDUCTOR                  7
-#define I2C_DEVICE_ID_SPRINTEK_CORPORATION              8
-#define I2C_DEVICE_ID_ESPROS_PHOTONICS_AG               9
-#define I2C_DEVICE_ID_FUJITSU_SEMICONDUCTOR            10
-#define I2C_DEVICE_ID_FLIR                             11
-#define I2C_DEVICE_ID_O2MICRO                          12
-#define I2C_DEVICE_ID_ATMEL                            13
-#define I2C_DEVICE_ID_NONE                         0xffff
-	u16 part_id;
-	u8 die_revision;
-};
-
 enum i2c_alert_protocol {
 	I2C_PROTOCOL_SMBUS_ALERT,
 	I2C_PROTOCOL_SMBUS_HOST_NOTIFY,
@@ -231,6 +138,7 @@ enum i2c_alert_protocol {
 /**
  * struct i2c_driver - represent an I2C device driver
  * @class: What kind of i2c device we instantiate (for detect)
+ * @attach_adapter: Callback for bus addition (deprecated)
  * @probe: Callback for device binding - soon to be deprecated
  * @probe_new: New callback for device binding
  * @remove: Callback for device unbinding
@@ -267,6 +175,11 @@ enum i2c_alert_protocol {
 struct i2c_driver {
 	unsigned int class;
 
+	/* Notifies the driver that a new bus has appeared. You should avoid
+	 * using this, it will be removed in a near future.
+	 */
+	int (*attach_adapter)(struct i2c_adapter *) __deprecated;
+
 	/* Standard driver model interfaces */
 	int (*probe)(struct i2c_client *, const struct i2c_device_id *);
 	int (*remove)(struct i2c_client *);
@@ -333,7 +246,6 @@ struct i2c_client {
 	char name[I2C_NAME_SIZE];
 	struct i2c_adapter *adapter;	/* the adapter we sit on	*/
 	struct device dev;		/* the device structure		*/
-	int init_irq;			/* irq set at initialization	*/
 	int irq;			/* irq issued by device		*/
 	struct list_head detected;
 #if IS_ENABLED(CONFIG_I2C_SLAVE)
@@ -392,8 +304,8 @@ static inline bool i2c_detect_slave_mode(struct device *dev) { return false; }
  * @type: chip type, to initialize i2c_client.name
  * @flags: to initialize i2c_client.flags
  * @addr: stored in i2c_client.addr
- * @dev_name: Overrides the default <busnr>-<addr> dev_name if set
  * @platform_data: stored in i2c_client.dev.platform_data
+ * @archdata: copied into i2c_client.dev.archdata
  * @of_node: pointer to OpenFirmware device node
  * @fwnode: device node supplied by the platform firmware
  * @properties: additional device properties for the device
@@ -416,8 +328,8 @@ struct i2c_board_info {
 	char		type[I2C_NAME_SIZE];
 	unsigned short	flags;
 	unsigned short	addr;
-	const char	*dev_name;
 	void		*platform_data;
+	struct dev_archdata	*archdata;
 	struct device_node *of_node;
 	struct fwnode_handle *fwnode;
 	const struct property_entry *properties;
@@ -440,7 +352,7 @@ struct i2c_board_info {
 	.type = dev_type, .addr = (dev_addr)
 
 
-#if IS_ENABLED(CONFIG_I2C)
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
 /* Add-on boards should register/unregister their devices; e.g. a board
  * with integrated I2C, a config eeprom, sensors, and a codec that's
  * used in conjunction with the primary hardware.
@@ -499,13 +411,9 @@ i2c_register_board_info(int busnum, struct i2c_board_info const *info,
  * @master_xfer: Issue a set of i2c transactions to the given I2C adapter
  *   defined by the msgs array, with num messages available to transfer via
  *   the adapter specified by adap.
- * @master_xfer_atomic: same as @master_xfer. Yet, only using atomic context
- *   so e.g. PMICs can be accessed very late before shutdown. Optional.
  * @smbus_xfer: Issue smbus transactions to the given I2C adapter. If this
  *   is not present, then the bus layer will try and convert the SMBus calls
  *   into I2C transfers instead.
- * @smbus_xfer_atomic: same as @smbus_xfer. Yet, only using atomic context
- *   so e.g. PMICs can be accessed very late before shutdown. Optional.
  * @functionality: Return the flags that this algorithm/adapter pair supports
  *   from the I2C_FUNC_* flags.
  * @reg_slave: Register given client to I2C slave mode of this adapter
@@ -516,33 +424,25 @@ i2c_register_board_info(int busnum, struct i2c_board_info const *info,
  * be addressed using the same bus algorithms - i.e. bit-banging or the PCF8584
  * to name two of the most common.
  *
- * The return codes from the @master_xfer{_atomic} fields should indicate the
- * type of error code that occurred during the transfer, as documented in the
- * Kernel Documentation file Documentation/i2c/fault-codes.
+ * The return codes from the @master_xfer field should indicate the type of
+ * error code that occurred during the transfer, as documented in the kernel
+ * Documentation file Documentation/i2c/fault-codes.
  */
 struct i2c_algorithm {
-	/*
-	 * If an adapter algorithm can't do I2C-level access, set master_xfer
-	 * to NULL. If an adapter algorithm can do SMBus access, set
-	 * smbus_xfer. If set to NULL, the SMBus protocol is simulated
-	 * using common I2C messages.
-	 *
-	 * master_xfer should return the number of messages successfully
-	 * processed, or a negative value on error
-	 */
+	/* If an adapter algorithm can't do I2C-level access, set master_xfer
+	   to NULL. If an adapter algorithm can do SMBus access, set
+	   smbus_xfer. If set to NULL, the SMBus protocol is simulated
+	   using common I2C messages */
+	/* master_xfer should return the number of messages successfully
+	   processed, or a negative value on error */
 	int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,
 			   int num);
-	int (*master_xfer_atomic)(struct i2c_adapter *adap,
-				   struct i2c_msg *msgs, int num);
-	int (*smbus_xfer)(struct i2c_adapter *adap, u16 addr,
-			  unsigned short flags, char read_write,
-			  u8 command, int size, union i2c_smbus_data *data);
-	int (*smbus_xfer_atomic)(struct i2c_adapter *adap, u16 addr,
-				 unsigned short flags, char read_write,
-				 u8 command, int size, union i2c_smbus_data *data);
+	int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,
+			   unsigned short flags, char read_write,
+			   u8 command, int size, union i2c_smbus_data *data);
 
 	/* To determine what the adapter supports */
-	u32 (*functionality)(struct i2c_adapter *adap);
+	u32 (*functionality) (struct i2c_adapter *);
 
 #if IS_ENABLED(CONFIG_I2C_SLAVE)
 	int (*reg_slave)(struct i2c_client *client);
@@ -571,7 +471,6 @@ struct i2c_lock_operations {
  * @scl_fall_ns: time SCL signal takes to fall in ns; t(f) in the I2C specification
  * @scl_int_delay_ns: time IP core additionally needs to setup SCL in ns
  * @sda_fall_ns: time SDA signal takes to fall in ns; t(f) in the I2C specification
- * @sda_hold_ns: time IP core additionally needs to hold SDA in ns
  */
 struct i2c_timings {
 	u32 bus_freq_hz;
@@ -579,52 +478,45 @@ struct i2c_timings {
 	u32 scl_fall_ns;
 	u32 scl_int_delay_ns;
 	u32 sda_fall_ns;
-	u32 sda_hold_ns;
 };
 
 /**
  * struct i2c_bus_recovery_info - I2C bus recovery information
  * @recover_bus: Recover routine. Either pass driver's recover_bus() routine, or
- *	i2c_generic_scl_recovery().
+ *	i2c_generic_scl_recovery() or i2c_generic_gpio_recovery().
  * @get_scl: This gets current value of SCL line. Mandatory for generic SCL
- *      recovery. Populated internally for generic GPIO recovery.
- * @set_scl: This sets/clears the SCL line. Mandatory for generic SCL recovery.
- *      Populated internally for generic GPIO recovery.
- * @get_sda: This gets current value of SDA line. This or set_sda() is mandatory
- *	for generic SCL recovery. Populated internally, if sda_gpio is a valid
- *	GPIO, for generic GPIO recovery.
- * @set_sda: This sets/clears the SDA line. This or get_sda() is mandatory for
- *	generic SCL recovery. Populated internally, if sda_gpio is a valid GPIO,
- *	for generic GPIO recovery.
- * @get_bus_free: Returns the bus free state as seen from the IP core in case it
- *	has a more complex internal logic than just reading SDA. Optional.
+ *      recovery. Used internally for generic GPIO recovery.
+ * @set_scl: This sets/clears SCL line. Mandatory for generic SCL recovery. Used
+ *      internally for generic GPIO recovery.
+ * @get_sda: This gets current value of SDA line. Optional for generic SCL
+ *      recovery. Used internally, if sda_gpio is a valid GPIO, for generic GPIO
+ *      recovery.
  * @prepare_recovery: This will be called before starting recovery. Platform may
  *	configure padmux here for SDA/SCL line or something else they want.
  * @unprepare_recovery: This will be called after completing recovery. Platform
  *	may configure padmux here for SDA/SCL line or something else they want.
- * @scl_gpiod: gpiod of the SCL line. Only required for GPIO recovery.
- * @sda_gpiod: gpiod of the SDA line. Only required for GPIO recovery.
+ * @scl_gpio: gpio number of the SCL line. Only required for GPIO recovery.
+ * @sda_gpio: gpio number of the SDA line. Only required for GPIO recovery.
  */
 struct i2c_bus_recovery_info {
-	int (*recover_bus)(struct i2c_adapter *adap);
+	int (*recover_bus)(struct i2c_adapter *);
 
-	int (*get_scl)(struct i2c_adapter *adap);
-	void (*set_scl)(struct i2c_adapter *adap, int val);
-	int (*get_sda)(struct i2c_adapter *adap);
-	void (*set_sda)(struct i2c_adapter *adap, int val);
-	int (*get_bus_free)(struct i2c_adapter *adap);
+	int (*get_scl)(struct i2c_adapter *);
+	void (*set_scl)(struct i2c_adapter *, int val);
+	int (*get_sda)(struct i2c_adapter *);
 
-	void (*prepare_recovery)(struct i2c_adapter *adap);
-	void (*unprepare_recovery)(struct i2c_adapter *adap);
+	void (*prepare_recovery)(struct i2c_adapter *);
+	void (*unprepare_recovery)(struct i2c_adapter *);
 
 	/* gpio recovery */
-	struct gpio_desc *scl_gpiod;
-	struct gpio_desc *sda_gpiod;
+	int scl_gpio;
+	int sda_gpio;
 };
 
 int i2c_recover_bus(struct i2c_adapter *adap);
 
 /* Generic recovery routines */
+int i2c_generic_gpio_recovery(struct i2c_adapter *adap);
 int i2c_generic_scl_recovery(struct i2c_adapter *adap);
 
 /**
@@ -670,10 +562,6 @@ struct i2c_adapter_quirks {
 					 I2C_AQ_COMB_READ_SECOND | I2C_AQ_COMB_SAME_ADDR)
 /* clock stretching is not supported */
 #define I2C_AQ_NO_CLK_STRETCH		BIT(4)
-/* message cannot have length of 0 */
-#define I2C_AQ_NO_ZERO_LEN_READ		BIT(5)
-#define I2C_AQ_NO_ZERO_LEN_WRITE	BIT(6)
-#define I2C_AQ_NO_ZERO_LEN		(I2C_AQ_NO_ZERO_LEN_READ | I2C_AQ_NO_ZERO_LEN_WRITE)
 
 /*
  * i2c_adapter is the structure used to identify a physical i2c bus along
@@ -693,9 +581,6 @@ struct i2c_adapter {
 	int timeout;			/* in jiffies */
 	int retries;
 	struct device dev;		/* the adapter device */
-	unsigned long locked_flags;	/* owned by the I2C core */
-#define I2C_ALF_IS_SUSPENDED		0
-#define I2C_ALF_SUSPEND_REPORTED	1
 
 	int nr;
 	char name[48];
@@ -778,36 +663,16 @@ i2c_unlock_bus(struct i2c_adapter *adapter, unsigned int flags)
 	adapter->lock_ops->unlock_bus(adapter, flags);
 }
 
-/**
- * i2c_mark_adapter_suspended - Report suspended state of the adapter to the core
- * @adap: Adapter to mark as suspended
- *
- * When using this helper to mark an adapter as suspended, the core will reject
- * further transfers to this adapter. The usage of this helper is optional but
- * recommended for devices having distinct handlers for system suspend and
- * runtime suspend. More complex devices are free to implement custom solutions
- * to reject transfers when suspended.
- */
-static inline void i2c_mark_adapter_suspended(struct i2c_adapter *adap)
+static inline void
+i2c_lock_adapter(struct i2c_adapter *adapter)
 {
-	i2c_lock_bus(adap, I2C_LOCK_ROOT_ADAPTER);
-	set_bit(I2C_ALF_IS_SUSPENDED, &adap->locked_flags);
-	i2c_unlock_bus(adap, I2C_LOCK_ROOT_ADAPTER);
+	i2c_lock_bus(adapter, I2C_LOCK_ROOT_ADAPTER);
 }
 
-/**
- * i2c_mark_adapter_resumed - Report resumed state of the adapter to the core
- * @adap: Adapter to mark as resumed
- *
- * When using this helper to mark an adapter as resumed, the core will allow
- * further transfers to this adapter. See also further notes to
- * @i2c_mark_adapter_suspended().
- */
-static inline void i2c_mark_adapter_resumed(struct i2c_adapter *adap)
+static inline void
+i2c_unlock_adapter(struct i2c_adapter *adapter)
 {
-	i2c_lock_bus(adap, I2C_LOCK_ROOT_ADAPTER);
-	clear_bit(I2C_ALF_IS_SUSPENDED, &adap->locked_flags);
-	i2c_unlock_bus(adap, I2C_LOCK_ROOT_ADAPTER);
+	i2c_unlock_bus(adapter, I2C_LOCK_ROOT_ADAPTER);
 }
 
 /*flags for the client struct: */
@@ -839,7 +704,7 @@ static inline void i2c_mark_adapter_resumed(struct i2c_adapter *adap)
 
 /* administration...
  */
-#if IS_ENABLED(CONFIG_I2C)
+#if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
 extern int i2c_add_adapter(struct i2c_adapter *);
 extern void i2c_del_adapter(struct i2c_adapter *);
 extern int i2c_add_numbered_adapter(struct i2c_adapter *);
@@ -902,9 +767,6 @@ static inline u8 i2c_8bit_addr_from_msg(const struct i2c_msg *msg)
 	return (msg->addr << 1) | (msg->flags & I2C_M_RD ? 1 : 0);
 }
 
-u8 *i2c_get_dma_safe_msg_buf(struct i2c_msg *msg, unsigned int threshold);
-void i2c_put_dma_safe_msg_buf(u8 *buf, struct i2c_msg *msg, bool xferred);
-
 int i2c_handle_smbus_host_notify(struct i2c_adapter *adap, unsigned short addr);
 /**
  * module_i2c_driver() - Helper macro for registering a modular I2C driver
@@ -945,9 +807,6 @@ extern const struct of_device_id
 *i2c_of_match_device(const struct of_device_id *matches,
 		     struct i2c_client *client);
 
-int of_i2c_get_board_info(struct device *dev, struct device_node *node,
-			  struct i2c_board_info *info);
-
 #else
 
 static inline struct i2c_client *of_find_i2c_device_by_node(struct device_node *node)
@@ -972,30 +831,13 @@ static inline const struct of_device_id
 	return NULL;
 }
 
-static inline int of_i2c_get_board_info(struct device *dev,
-					struct device_node *node,
-					struct i2c_board_info *info)
-{
-	return -ENOTSUPP;
-}
-
 #endif /* CONFIG_OF */
 
-struct acpi_resource;
-struct acpi_resource_i2c_serialbus;
-
 #if IS_ENABLED(CONFIG_ACPI)
-bool i2c_acpi_get_i2c_resource(struct acpi_resource *ares,
-			       struct acpi_resource_i2c_serialbus **i2c);
 u32 i2c_acpi_find_bus_speed(struct device *dev);
 struct i2c_client *i2c_acpi_new_device(struct device *dev, int index,
 				       struct i2c_board_info *info);
 #else
-static inline bool i2c_acpi_get_i2c_resource(struct acpi_resource *ares,
-					     struct acpi_resource_i2c_serialbus **i2c)
-{
-	return false;
-}
 static inline u32 i2c_acpi_find_bus_speed(struct device *dev)
 {
 	return 0;
