diff --git a/drivers/i2c/i2c-core-base.c b/drivers/i2c/i2c-core-base.c
index 9732a81bb..56e46581b 100644
--- a/drivers/i2c/i2c-core-base.c
+++ b/drivers/i2c/i2c-core-base.c
@@ -27,9 +27,8 @@
 #include <linux/delay.h>
 #include <linux/err.h>
 #include <linux/errno.h>
-#include <linux/gpio/consumer.h>
+#include <linux/gpio.h>
 #include <linux/i2c.h>
-#include <linux/i2c-smbus.h>
 #include <linux/idr.h>
 #include <linux/init.h>
 #include <linux/irqflags.h>
@@ -58,29 +57,27 @@
 #define I2C_ADDR_7BITS_MAX	0x77
 #define I2C_ADDR_7BITS_COUNT	(I2C_ADDR_7BITS_MAX + 1)
 
-#define I2C_ADDR_DEVICE_ID	0x7c
-
 /*
  * core_lock protects i2c_adapter_idr, and guarantees that device detection,
- * deletion of detected devices are serialized
+ * deletion of detected devices, and attach_adapter calls are serialized
  */
 static DEFINE_MUTEX(core_lock);
 static DEFINE_IDR(i2c_adapter_idr);
 
 static int i2c_detect(struct i2c_adapter *adapter, struct i2c_driver *driver);
 
-static DEFINE_STATIC_KEY_FALSE(i2c_trace_msg_key);
+static struct static_key i2c_trace_msg = STATIC_KEY_INIT_FALSE;
 static bool is_registered;
 
 int i2c_transfer_trace_reg(void)
 {
-	static_branch_inc(&i2c_trace_msg_key);
+	static_key_slow_inc(&i2c_trace_msg);
 	return 0;
 }
 
 void i2c_transfer_trace_unreg(void)
 {
-	static_branch_dec(&i2c_trace_msg_key);
+	static_key_slow_dec(&i2c_trace_msg);
 }
 
 const struct i2c_device_id *i2c_match_id(const struct i2c_device_id *id,
@@ -126,10 +123,6 @@ static int i2c_device_uevent(struct device *dev, struct kobj_uevent_env *env)
 	struct i2c_client *client = to_i2c_client(dev);
 	int rc;
 
-	rc = of_device_uevent_modalias(dev, env);
-	if (rc != -ENODEV)
-		return rc;
-
 	rc = acpi_device_uevent_modalias(dev, env);
 	if (rc != -ENODEV)
 		return rc;
@@ -140,38 +133,52 @@ static int i2c_device_uevent(struct device *dev, struct kobj_uevent_env *env)
 /* i2c bus recovery routines */
 static int get_scl_gpio_value(struct i2c_adapter *adap)
 {
-	return gpiod_get_value_cansleep(adap->bus_recovery_info->scl_gpiod);
+	return gpio_get_value(adap->bus_recovery_info->scl_gpio);
 }
 
 static void set_scl_gpio_value(struct i2c_adapter *adap, int val)
 {
-	gpiod_set_value_cansleep(adap->bus_recovery_info->scl_gpiod, val);
+	gpio_set_value(adap->bus_recovery_info->scl_gpio, val);
 }
 
 static int get_sda_gpio_value(struct i2c_adapter *adap)
 {
-	return gpiod_get_value_cansleep(adap->bus_recovery_info->sda_gpiod);
+	return gpio_get_value(adap->bus_recovery_info->sda_gpio);
 }
 
-static void set_sda_gpio_value(struct i2c_adapter *adap, int val)
+static int i2c_get_gpios_for_recovery(struct i2c_adapter *adap)
 {
-	gpiod_set_value_cansleep(adap->bus_recovery_info->sda_gpiod, val);
+	struct i2c_bus_recovery_info *bri = adap->bus_recovery_info;
+	struct device *dev = &adap->dev;
+	int ret = 0;
+
+	ret = gpio_request_one(bri->scl_gpio, GPIOF_OPEN_DRAIN |
+			GPIOF_OUT_INIT_HIGH, "i2c-scl");
+	if (ret) {
+		dev_warn(dev, "Can't get SCL gpio: %d\n", bri->scl_gpio);
+		return ret;
+	}
+
+	if (bri->get_sda) {
+		if (gpio_request_one(bri->sda_gpio, GPIOF_IN, "i2c-sda")) {
+			/* work without SDA polling */
+			dev_warn(dev, "Can't get SDA gpio: %d. Not using SDA polling\n",
+					bri->sda_gpio);
+			bri->get_sda = NULL;
+		}
+	}
+
+	return ret;
 }
 
-static int i2c_generic_bus_free(struct i2c_adapter *adap)
+static void i2c_put_gpios_for_recovery(struct i2c_adapter *adap)
 {
 	struct i2c_bus_recovery_info *bri = adap->bus_recovery_info;
-	int ret = -EOPNOTSUPP;
 
-	if (bri->get_bus_free)
-		ret = bri->get_bus_free(adap);
-	else if (bri->get_sda)
-		ret = bri->get_sda(adap);
+	if (bri->get_sda)
+		gpio_free(bri->sda_gpio);
 
-	if (ret < 0)
-		return ret;
-
-	return ret ? 0 : -EBUSY;
+	gpio_free(bri->scl_gpio);
 }
 
 /*
@@ -182,31 +189,25 @@ static int i2c_generic_bus_free(struct i2c_adapter *adap)
 #define RECOVERY_NDELAY		5000
 #define RECOVERY_CLK_CNT	9
 
-int i2c_generic_scl_recovery(struct i2c_adapter *adap)
+static int i2c_generic_recovery(struct i2c_adapter *adap)
 {
 	struct i2c_bus_recovery_info *bri = adap->bus_recovery_info;
-	int i = 0, scl = 1, ret = 0;
+	int i = 0, val = 1, ret = 0;
 
 	if (bri->prepare_recovery)
 		bri->prepare_recovery(adap);
 
-	/*
-	 * If we can set SDA, we will always create a STOP to ensure additional
-	 * pulses will do no harm. This is achieved by letting SDA follow SCL
-	 * half a cycle later. Check the 'incomplete_write_byte' fault injector
-	 * for details.
-	 */
-	bri->set_scl(adap, scl);
-	ndelay(RECOVERY_NDELAY / 2);
-	if (bri->set_sda)
-		bri->set_sda(adap, scl);
-	ndelay(RECOVERY_NDELAY / 2);
+	bri->set_scl(adap, val);
+	ndelay(RECOVERY_NDELAY);
 
 	/*
 	 * By this time SCL is high, as we need to give 9 falling-rising edges
 	 */
 	while (i++ < RECOVERY_CLK_CNT * 2) {
-		if (scl) {
+		if (val) {
+			/* Break if SDA is high */
+			if (bri->get_sda && bri->get_sda(adap))
+					break;
 			/* SCL shouldn't be low here */
 			if (!bri->get_scl(adap)) {
 				dev_err(&adap->dev,
@@ -216,32 +217,38 @@ int i2c_generic_scl_recovery(struct i2c_adapter *adap)
 			}
 		}
 
-		scl = !scl;
-		bri->set_scl(adap, scl);
-		/* Creating STOP again, see above */
-		ndelay(RECOVERY_NDELAY / 2);
-		if (bri->set_sda)
-			bri->set_sda(adap, scl);
-		ndelay(RECOVERY_NDELAY / 2);
-
-		if (scl) {
-			ret = i2c_generic_bus_free(adap);
-			if (ret == 0)
-				break;
-		}
+		val = !val;
+		bri->set_scl(adap, val);
+		ndelay(RECOVERY_NDELAY);
 	}
 
-	/* If we can't check bus status, assume recovery worked */
-	if (ret == -EOPNOTSUPP)
-		ret = 0;
-
 	if (bri->unprepare_recovery)
 		bri->unprepare_recovery(adap);
 
 	return ret;
 }
+
+int i2c_generic_scl_recovery(struct i2c_adapter *adap)
+{
+	return i2c_generic_recovery(adap);
+}
 EXPORT_SYMBOL_GPL(i2c_generic_scl_recovery);
 
+int i2c_generic_gpio_recovery(struct i2c_adapter *adap)
+{
+	int ret;
+
+	ret = i2c_get_gpios_for_recovery(adap);
+	if (ret)
+		return ret;
+
+	ret = i2c_generic_recovery(adap);
+	i2c_put_gpios_for_recovery(adap);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(i2c_generic_gpio_recovery);
+
 int i2c_recover_bus(struct i2c_adapter *adap)
 {
 	if (!adap->bus_recovery_info)
@@ -265,28 +272,26 @@ static void i2c_init_recovery(struct i2c_adapter *adap)
 		goto err;
 	}
 
-	if (bri->scl_gpiod && bri->recover_bus == i2c_generic_scl_recovery) {
-		bri->get_scl = get_scl_gpio_value;
-		bri->set_scl = set_scl_gpio_value;
-		if (bri->sda_gpiod) {
-			bri->get_sda = get_sda_gpio_value;
-			/* FIXME: add proper flag instead of '0' once available */
-			if (gpiod_get_direction(bri->sda_gpiod) == 0)
-				bri->set_sda = set_sda_gpio_value;
+	/* Generic GPIO recovery */
+	if (bri->recover_bus == i2c_generic_gpio_recovery) {
+		if (!gpio_is_valid(bri->scl_gpio)) {
+			err_str = "invalid SCL gpio";
+			goto err;
 		}
-		return;
-	}
 
-	if (bri->recover_bus == i2c_generic_scl_recovery) {
+		if (gpio_is_valid(bri->sda_gpio))
+			bri->get_sda = get_sda_gpio_value;
+		else
+			bri->get_sda = NULL;
+
+		bri->get_scl = get_scl_gpio_value;
+		bri->set_scl = set_scl_gpio_value;
+	} else if (bri->recover_bus == i2c_generic_scl_recovery) {
 		/* Generic SCL recovery */
 		if (!bri->set_scl || !bri->get_scl) {
 			err_str = "no {get|set}_scl() found";
 			goto err;
 		}
-		if (!bri->set_sda && !bri->get_sda) {
-			err_str = "either get_sda() or set_sda() needed";
-			goto err;
-		}
 	}
 
 	return;
@@ -306,7 +311,10 @@ static int i2c_smbus_host_notify_to_irq(const struct i2c_client *client)
 	if (client->flags & I2C_CLIENT_TEN)
 		return -EINVAL;
 
-	irq = irq_create_mapping(adap->host_notify_domain, client->addr);
+	irq = irq_find_mapping(adap->host_notify_domain, client->addr);
+	if (!irq)
+		irq = irq_create_mapping(adap->host_notify_domain,
+					 client->addr);
 
 	return irq > 0 ? irq : -ENXIO;
 }
@@ -327,8 +335,6 @@ static int i2c_device_probe(struct device *dev)
 
 		if (client->flags & I2C_CLIENT_HOST_NOTIFY) {
 			dev_dbg(dev, "Using Host Notify IRQ\n");
-			/* Keep adapter active when Host Notify is required */
-			pm_runtime_get_sync(&client->adapter->dev);
 			irq = i2c_smbus_host_notify_to_irq(client);
 		} else if (dev->of_node) {
 			irq = of_irq_get_byname(dev->of_node, "irq");
@@ -384,7 +390,7 @@ static int i2c_device_probe(struct device *dev)
 		goto err_clear_wakeup_irq;
 
 	status = dev_pm_domain_attach(&client->dev, true);
-	if (status)
+	if (status == -EPROBE_DEFER)
 		goto err_clear_wakeup_irq;
 
 	/*
@@ -432,10 +438,6 @@ static int i2c_device_remove(struct device *dev)
 	dev_pm_clear_wake_irq(&client->dev);
 	device_init_wakeup(&client->dev, false);
 
-	client->irq = client->init_irq;
-	if (client->flags & I2C_CLIENT_HOST_NOTIFY)
-		pm_runtime_put(&client->adapter->dev);
-
 	return status;
 }
 
@@ -470,10 +472,6 @@ show_modalias(struct device *dev, struct device_attribute *attr, char *buf)
 	struct i2c_client *client = to_i2c_client(dev);
 	int len;
 
-	len = of_device_modalias(dev, buf, PAGE_SIZE);
-	if (len != -ENODEV)
-		return len;
-
 	len = acpi_device_modalias(dev, buf, PAGE_SIZE -1);
 	if (len != -ENODEV)
 		return len;
@@ -542,7 +540,7 @@ static unsigned short i2c_encode_flags_to_addr(struct i2c_client *client)
 
 /* This is a permissive address validity check, I2C address map constraints
  * are purposely not enforced, except for the general call address. */
-static int i2c_check_addr_validity(unsigned int addr, unsigned short flags)
+int i2c_check_addr_validity(unsigned addr, unsigned short flags)
 {
 	if (flags & I2C_CLIENT_TEN) {
 		/* 10-bit address, all values are valid */
@@ -640,7 +638,7 @@ static int i2c_check_addr_busy(struct i2c_adapter *adapter, int addr)
 static void i2c_adapter_lock_bus(struct i2c_adapter *adapter,
 				 unsigned int flags)
 {
-	rt_mutex_lock_nested(&adapter->bus_lock, i2c_adapter_depth(adapter));
+	rt_mutex_lock(&adapter->bus_lock);
 }
 
 /**
@@ -668,16 +666,10 @@ static void i2c_adapter_unlock_bus(struct i2c_adapter *adapter,
 }
 
 static void i2c_dev_set_name(struct i2c_adapter *adap,
-			     struct i2c_client *client,
-			     struct i2c_board_info const *info)
+			     struct i2c_client *client)
 {
 	struct acpi_device *adev = ACPI_COMPANION(&client->dev);
 
-	if (info && info->dev_name) {
-		dev_set_name(&client->dev, "i2c-%s", info->dev_name);
-		return;
-	}
-
 	if (adev) {
 		dev_set_name(&client->dev, "i2c-%s", acpi_dev_name(adev));
 		return;
@@ -742,14 +734,17 @@ i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)
 	client->adapter = adap;
 
 	client->dev.platform_data = info->platform_data;
+
+	if (info->archdata)
+		client->dev.archdata = *info->archdata;
+
 	client->flags = info->flags;
 	client->addr = info->addr;
 
-	client->init_irq = info->irq;
-	if (!client->init_irq)
-		client->init_irq = i2c_dev_irq_from_resources(info->resources,
+	client->irq = info->irq;
+	if (!client->irq)
+		client->irq = i2c_dev_irq_from_resources(info->resources,
 							 info->num_resources);
-	client->irq = client->init_irq;
 
 	strlcpy(client->name, info->type, sizeof(client->name));
 
@@ -768,10 +763,10 @@ i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)
 	client->dev.parent = &client->adapter->dev;
 	client->dev.bus = &i2c_bus_type;
 	client->dev.type = &i2c_client_type;
-	client->dev.of_node = of_node_get(info->of_node);
+	client->dev.of_node = info->of_node;
 	client->dev.fwnode = info->fwnode;
 
-	i2c_dev_set_name(adap, client, info);
+	i2c_dev_set_name(adap, client);
 
 	if (info->properties) {
 		status = device_add_properties(&client->dev, info->properties);
@@ -779,7 +774,7 @@ i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)
 			dev_err(&adap->dev,
 				"Failed to add properties to client %s: %d\n",
 				client->name, status);
-			goto out_err_put_of_node;
+			goto out_err;
 		}
 	}
 
@@ -795,8 +790,6 @@ i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)
 out_free_props:
 	if (info->properties)
 		device_remove_properties(&client->dev);
-out_err_put_of_node:
-	of_node_put(info->of_node);
 out_err:
 	dev_err(&adap->dev,
 		"Failed to register i2c client %s at 0x%02x (%d)\n",
@@ -815,14 +808,8 @@ EXPORT_SYMBOL_GPL(i2c_new_device);
  */
 void i2c_unregister_device(struct i2c_client *client)
 {
-	if (!client)
-		return;
-
-	if (client->dev.of_node) {
+	if (client->dev.of_node)
 		of_node_clear_flag(client->dev.of_node, OF_POPULATED);
-		of_node_put(client->dev.of_node);
-	}
-
 	if (ACPI_COMPANION(&client->dev))
 		acpi_device_clear_enumerated(ACPI_COMPANION(&client->dev));
 	device_unregister(&client->dev);
@@ -1128,6 +1115,15 @@ static int i2c_do_add_adapter(struct i2c_driver *driver,
 	/* Detect supported devices on that bus, and instantiate them */
 	i2c_detect(adap, driver);
 
+	/* Let legacy drivers scan this bus for matching devices */
+	if (driver->attach_adapter) {
+		dev_warn(&adap->dev, "%s: attach_adapter method is deprecated\n",
+			 driver->driver.name);
+		dev_warn(&adap->dev,
+			 "Please use another way to instantiate your i2c_client\n");
+		/* We ignore the return code; if it fails, too bad */
+		driver->attach_adapter(adap);
+	}
 	return 0;
 }
 
@@ -1237,7 +1233,6 @@ static int i2c_register_adapter(struct i2c_adapter *adap)
 	if (!adap->lock_ops)
 		adap->lock_ops = &i2c_adapter_lock_ops;
 
-	adap->locked_flags = 0;
 	rt_mutex_init(&adap->bus_lock);
 	rt_mutex_init(&adap->mux_lock);
 	mutex_init(&adap->userspace_clients_lock);
@@ -1264,10 +1259,6 @@ static int i2c_register_adapter(struct i2c_adapter *adap)
 		goto out_list;
 	}
 
-	res = of_i2c_setup_smbus_alert(adap);
-	if (res)
-		goto out_reg;
-
 	dev_dbg(&adap->dev, "adapter [%s] registered\n", adap->name);
 
 	pm_runtime_no_callbacks(&adap->dev);
@@ -1299,10 +1290,6 @@ static int i2c_register_adapter(struct i2c_adapter *adap)
 
 	return 0;
 
-out_reg:
-	init_completion(&adap->dev_released);
-	device_unregister(&adap->dev);
-	wait_for_completion(&adap->dev_released);
 out_list:
 	mutex_lock(&core_lock);
 	idr_remove(&i2c_adapter_idr, adap->nr);
@@ -1430,7 +1417,8 @@ static int __unregister_client(struct device *dev, void *dummy)
 static int __unregister_dummy(struct device *dev, void *dummy)
 {
 	struct i2c_client *client = i2c_verify_client(dev);
-	i2c_unregister_device(client);
+	if (client)
+		i2c_unregister_device(client);
 	return 0;
 }
 
@@ -1572,8 +1560,6 @@ void i2c_parse_fw_timings(struct device *dev, struct i2c_timings *t, bool use_de
 	ret = device_property_read_u32(dev, "i2c-sda-falling-time-ns", &t->sda_fall_ns);
 	if (ret && use_defaults)
 		t->sda_fall_ns = t->scl_fall_ns;
-
-	device_property_read_u32(dev, "i2c-sda-hold-time-ns", &t->sda_hold_ns);
 }
 EXPORT_SYMBOL_GPL(i2c_parse_fw_timings);
 
@@ -1837,15 +1823,9 @@ static int i2c_check_for_quirks(struct i2c_adapter *adap, struct i2c_msg *msgs,
 		if (msgs[i].flags & I2C_M_RD) {
 			if (do_len_check && i2c_quirk_exceeded(len, q->max_read_len))
 				return i2c_quirk_error(adap, &msgs[i], "msg too long");
-
-			if (q->flags & I2C_AQ_NO_ZERO_LEN_READ && len == 0)
-				return i2c_quirk_error(adap, &msgs[i], "no zero length");
 		} else {
 			if (do_len_check && i2c_quirk_exceeded(len, q->max_write_len))
 				return i2c_quirk_error(adap, &msgs[i], "msg too long");
-
-			if (q->flags & I2C_AQ_NO_ZERO_LEN_WRITE && len == 0)
-				return i2c_quirk_error(adap, &msgs[i], "no zero length");
 		}
 	}
 
@@ -1869,22 +1849,14 @@ int __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 	unsigned long orig_jiffies;
 	int ret, try;
 
-	if (WARN_ON(!msgs || num < 1))
-		return -EINVAL;
-
-	ret = __i2c_check_suspended(adap);
-	if (ret)
-		return ret;
-
 	if (adap->quirks && i2c_check_for_quirks(adap, msgs, num))
 		return -EOPNOTSUPP;
 
-	/*
-	 * i2c_trace_msg_key gets enabled when tracepoint i2c_transfer gets
+	/* i2c_trace_msg gets enabled when tracepoint i2c_transfer gets
 	 * enabled.  This is an efficient way of keeping the for-loop from
 	 * being executed when not needed.
 	 */
-	if (static_branch_unlikely(&i2c_trace_msg_key)) {
+	if (static_key_false(&i2c_trace_msg)) {
 		int i;
 		for (i = 0; i < num; i++)
 			if (msgs[i].flags & I2C_M_RD)
@@ -1896,23 +1868,19 @@ int __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 	/* Retry automatically on arbitration loss */
 	orig_jiffies = jiffies;
 	for (ret = 0, try = 0; try <= adap->retries; try++) {
-		if (i2c_in_atomic_xfer_mode() && adap->algo->master_xfer_atomic)
-			ret = adap->algo->master_xfer_atomic(adap, msgs, num);
-		else
-			ret = adap->algo->master_xfer(adap, msgs, num);
-
+		ret = adap->algo->master_xfer(adap, msgs, num);
 		if (ret != -EAGAIN)
 			break;
 		if (time_after(jiffies, orig_jiffies + adap->timeout))
 			break;
 	}
 
-	if (static_branch_unlikely(&i2c_trace_msg_key)) {
+	if (static_key_false(&i2c_trace_msg)) {
 		int i;
 		for (i = 0; i < ret; i++)
 			if (msgs[i].flags & I2C_M_RD)
 				trace_i2c_reply(adap, &msgs[i], i);
-		trace_i2c_result(adap, num, ret);
+		trace_i2c_result(adap, i, ret);
 	}
 
 	return ret;
@@ -1935,11 +1903,6 @@ int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 {
 	int ret;
 
-	if (!adap->algo->master_xfer) {
-		dev_dbg(&adap->dev, "I2C level transfers not supported\n");
-		return -EOPNOTSUPP;
-	}
-
 	/* REVISIT the fault reporting model here is weak:
 	 *
 	 *  - When we get an error after receiving N bytes from a slave,
@@ -1956,78 +1919,96 @@ int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 	 *    one (discarding status on the second message) or errno
 	 *    (discarding status on the first one).
 	 */
-	ret = __i2c_lock_bus_helper(adap);
-	if (ret)
-		return ret;
 
-	ret = __i2c_transfer(adap, msgs, num);
-	i2c_unlock_bus(adap, I2C_LOCK_SEGMENT);
+	if (adap->algo->master_xfer) {
+#ifdef DEBUG
+		for (ret = 0; ret < num; ret++) {
+			dev_dbg(&adap->dev,
+				"master_xfer[%d] %c, addr=0x%02x, len=%d%s\n",
+				ret, (msgs[ret].flags & I2C_M_RD) ? 'R' : 'W',
+				msgs[ret].addr, msgs[ret].len,
+				(msgs[ret].flags & I2C_M_RECV_LEN) ? "+" : "");
+		}
+#endif
+
+		if (in_atomic() || irqs_disabled()) {
+			ret = i2c_trylock_bus(adap, I2C_LOCK_SEGMENT);
+			if (!ret)
+				/* I2C activity is ongoing. */
+				return -EAGAIN;
+		} else {
+			i2c_lock_bus(adap, I2C_LOCK_SEGMENT);
+		}
 
-	return ret;
+		ret = __i2c_transfer(adap, msgs, num);
+		i2c_unlock_bus(adap, I2C_LOCK_SEGMENT);
+
+		return ret;
+	} else {
+		dev_dbg(&adap->dev, "I2C level transfers not supported\n");
+		return -EOPNOTSUPP;
+	}
 }
 EXPORT_SYMBOL(i2c_transfer);
 
 /**
- * i2c_transfer_buffer_flags - issue a single I2C message transferring data
- *			       to/from a buffer
+ * i2c_master_send - issue a single I2C message in master transmit mode
  * @client: Handle to slave device
- * @buf: Where the data is stored
- * @count: How many bytes to transfer, must be less than 64k since msg.len is u16
- * @flags: The flags to be used for the message, e.g. I2C_M_RD for reads
+ * @buf: Data that will be written to the slave
+ * @count: How many bytes to write, must be less than 64k since msg.len is u16
  *
- * Returns negative errno, or else the number of bytes transferred.
+ * Returns negative errno, or else the number of bytes written.
  */
-int i2c_transfer_buffer_flags(const struct i2c_client *client, char *buf,
-			      int count, u16 flags)
+int i2c_master_send(const struct i2c_client *client, const char *buf, int count)
 {
 	int ret;
-	struct i2c_msg msg = {
-		.addr = client->addr,
-		.flags = flags | (client->flags & I2C_M_TEN),
-		.len = count,
-		.buf = buf,
-	};
+	struct i2c_adapter *adap = client->adapter;
+	struct i2c_msg msg;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags & I2C_M_TEN;
+	msg.len = count;
+	msg.buf = (char *)buf;
 
-	ret = i2c_transfer(client->adapter, &msg, 1);
+	ret = i2c_transfer(adap, &msg, 1);
 
 	/*
-	 * If everything went ok (i.e. 1 msg transferred), return #bytes
-	 * transferred, else error code.
+	 * If everything went ok (i.e. 1 msg transmitted), return #bytes
+	 * transmitted, else error code.
 	 */
 	return (ret == 1) ? count : ret;
 }
-EXPORT_SYMBOL(i2c_transfer_buffer_flags);
+EXPORT_SYMBOL(i2c_master_send);
 
 /**
- * i2c_get_device_id - get manufacturer, part id and die revision of a device
- * @client: The device to query
- * @id: The queried information
+ * i2c_master_recv - issue a single I2C message in master receive mode
+ * @client: Handle to slave device
+ * @buf: Where to store data read from slave
+ * @count: How many bytes to read, must be less than 64k since msg.len is u16
  *
- * Returns negative errno on error, zero on success.
+ * Returns negative errno, or else the number of bytes read.
  */
-int i2c_get_device_id(const struct i2c_client *client,
-		      struct i2c_device_identity *id)
+int i2c_master_recv(const struct i2c_client *client, char *buf, int count)
 {
 	struct i2c_adapter *adap = client->adapter;
-	union i2c_smbus_data raw_id;
+	struct i2c_msg msg;
 	int ret;
 
-	if (!i2c_check_functionality(adap, I2C_FUNC_SMBUS_READ_I2C_BLOCK))
-		return -EOPNOTSUPP;
+	msg.addr = client->addr;
+	msg.flags = client->flags & I2C_M_TEN;
+	msg.flags |= I2C_M_RD;
+	msg.len = count;
+	msg.buf = buf;
 
-	raw_id.block[0] = 3;
-	ret = i2c_smbus_xfer(adap, I2C_ADDR_DEVICE_ID, 0,
-			     I2C_SMBUS_READ, client->addr << 1,
-			     I2C_SMBUS_I2C_BLOCK_DATA, &raw_id);
-	if (ret)
-		return ret;
+	ret = i2c_transfer(adap, &msg, 1);
 
-	id->manufacturer_id = (raw_id.block[1] << 4) | (raw_id.block[2] >> 4);
-	id->part_id = ((raw_id.block[2] & 0xf) << 5) | (raw_id.block[3] >> 3);
-	id->die_revision = raw_id.block[3] & 0x7;
-	return 0;
+	/*
+	 * If everything went ok (i.e. 1 msg received), return #bytes received,
+	 * else error code.
+	 */
+	return (ret == 1) ? count : ret;
 }
-EXPORT_SYMBOL_GPL(i2c_get_device_id);
+EXPORT_SYMBOL(i2c_master_recv);
 
 /* ----------------------------------------------------
  * the i2c address scanning function
@@ -2260,58 +2241,6 @@ void i2c_put_adapter(struct i2c_adapter *adap)
 }
 EXPORT_SYMBOL(i2c_put_adapter);
 
-/**
- * i2c_get_dma_safe_msg_buf() - get a DMA safe buffer for the given i2c_msg
- * @msg: the message to be checked
- * @threshold: the minimum number of bytes for which using DMA makes sense.
- *	       Should at least be 1.
- *
- * Return: NULL if a DMA safe buffer was not obtained. Use msg->buf with PIO.
- *	   Or a valid pointer to be used with DMA. After use, release it by
- *	   calling i2c_put_dma_safe_msg_buf().
- *
- * This function must only be called from process context!
- */
-u8 *i2c_get_dma_safe_msg_buf(struct i2c_msg *msg, unsigned int threshold)
-{
-	/* also skip 0-length msgs for bogus thresholds of 0 */
-	if (!threshold)
-		pr_debug("DMA buffer for addr=0x%02x with length 0 is bogus\n",
-			 msg->addr);
-	if (msg->len < threshold || msg->len == 0)
-		return NULL;
-
-	if (msg->flags & I2C_M_DMA_SAFE)
-		return msg->buf;
-
-	pr_debug("using bounce buffer for addr=0x%02x, len=%d\n",
-		 msg->addr, msg->len);
-
-	if (msg->flags & I2C_M_RD)
-		return kzalloc(msg->len, GFP_KERNEL);
-	else
-		return kmemdup(msg->buf, msg->len, GFP_KERNEL);
-}
-EXPORT_SYMBOL_GPL(i2c_get_dma_safe_msg_buf);
-
-/**
- * i2c_put_dma_safe_msg_buf - release DMA safe buffer and sync with i2c_msg
- * @buf: the buffer obtained from i2c_get_dma_safe_msg_buf(). May be NULL.
- * @msg: the message which the buffer corresponds to
- * @xferred: bool saying if the message was transferred
- */
-void i2c_put_dma_safe_msg_buf(u8 *buf, struct i2c_msg *msg, bool xferred)
-{
-	if (!buf || buf == msg->buf)
-		return;
-
-	if (xferred && msg->flags & I2C_M_RD)
-		memcpy(msg->buf, buf, msg->len);
-
-	kfree(buf);
-}
-EXPORT_SYMBOL_GPL(i2c_put_dma_safe_msg_buf);
-
 MODULE_AUTHOR("Simon G. Vogl <simon@tk.uni-linz.ac.at>");
 MODULE_DESCRIPTION("I2C-Bus main module");
 MODULE_LICENSE("GPL");
diff --git a/drivers/i2c/i2c-core.h b/drivers/i2c/i2c-core.h
index c88cfef81..3d3d9bf02 100644
--- a/drivers/i2c/i2c-core.h
+++ b/drivers/i2c/i2c-core.h
@@ -27,44 +27,9 @@ extern struct rw_semaphore	__i2c_board_lock;
 extern struct list_head	__i2c_board_list;
 extern int		__i2c_first_dynamic_bus_num;
 
+int i2c_check_addr_validity(unsigned addr, unsigned short flags);
 int i2c_check_7bit_addr_validity_strict(unsigned short addr);
 
-/*
- * We only allow atomic transfers for very late communication, e.g. to send
- * the powerdown command to a PMIC. Atomic transfers are a corner case and not
- * for generic use!
- */
-static inline bool i2c_in_atomic_xfer_mode(void)
-{
-	return system_state > SYSTEM_RUNNING && irqs_disabled();
-}
-
-static inline int __i2c_lock_bus_helper(struct i2c_adapter *adap)
-{
-	int ret = 0;
-
-	if (i2c_in_atomic_xfer_mode()) {
-		WARN(!adap->algo->master_xfer_atomic && !adap->algo->smbus_xfer_atomic,
-		     "No atomic I2C transfer handler for '%s'\n", dev_name(&adap->dev));
-		ret = i2c_trylock_bus(adap, I2C_LOCK_SEGMENT) ? 0 : -EAGAIN;
-	} else {
-		i2c_lock_bus(adap, I2C_LOCK_SEGMENT);
-	}
-
-	return ret;
-}
-
-static inline int __i2c_check_suspended(struct i2c_adapter *adap)
-{
-	if (test_bit(I2C_ALF_IS_SUSPENDED, &adap->locked_flags)) {
-		if (!test_and_set_bit(I2C_ALF_SUSPEND_REPORTED, &adap->locked_flags))
-			dev_WARN(&adap->dev, "Transfer while suspended\n");
-		return -ESHUTDOWN;
-	}
-
-	return 0;
-}
-
 #ifdef CONFIG_ACPI
 const struct acpi_device_id *
 i2c_acpi_match_device(const struct acpi_device_id *matches,
