diff --git a/drivers/i2c/i2c-core-smbus.c b/drivers/i2c/i2c-core-smbus.c
index 788d42f2a..e54a9b835 100644
--- a/drivers/i2c/i2c-core-smbus.c
+++ b/drivers/i2c/i2c-core-smbus.c
@@ -17,10 +17,6 @@
 #include <linux/device.h>
 #include <linux/err.h>
 #include <linux/i2c.h>
-#include <linux/i2c-smbus.h>
-#include <linux/slab.h>
-
-#include "i2c-core.h"
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/smbus.h>
@@ -294,37 +290,17 @@ s32 i2c_smbus_write_i2c_block_data(const struct i2c_client *client, u8 command,
 }
 EXPORT_SYMBOL(i2c_smbus_write_i2c_block_data);
 
-static void i2c_smbus_try_get_dmabuf(struct i2c_msg *msg, u8 init_val)
-{
-	bool is_read = msg->flags & I2C_M_RD;
-	unsigned char *dma_buf;
-
-	dma_buf = kzalloc(I2C_SMBUS_BLOCK_MAX + (is_read ? 2 : 3), GFP_KERNEL);
-	if (!dma_buf)
-		return;
-
-	msg->buf = dma_buf;
-	msg->flags |= I2C_M_DMA_SAFE;
-
-	if (init_val)
-		msg->buf[0] = init_val;
-}
-
-/*
- * Simulate a SMBus command using the I2C protocol.
- * No checking of parameters is done!
- */
+/* Simulate a SMBus command using the i2c protocol
+   No checking of parameters is done!  */
 static s32 i2c_smbus_xfer_emulated(struct i2c_adapter *adapter, u16 addr,
 				   unsigned short flags,
 				   char read_write, u8 command, int size,
 				   union i2c_smbus_data *data)
 {
-	/*
-	 * So we need to generate a series of msgs. In the case of writing, we
-	 * need to use only one message; when reading, we need two. We
-	 * initialize most things with sane defaults, to keep the code below
-	 * somewhat simpler.
-	 */
+	/* So we need to generate a series of msgs. In the case of writing, we
+	  need to use only one message; when reading, we need two. We initialize
+	  most things with sane defaults, to keep the code below somewhat
+	  simpler. */
 	unsigned char msgbuf0[I2C_SMBUS_BLOCK_MAX+3];
 	unsigned char msgbuf1[I2C_SMBUS_BLOCK_MAX+2];
 	int num = read_write == I2C_SMBUS_READ ? 2 : 1;
@@ -391,7 +367,6 @@ static s32 i2c_smbus_xfer_emulated(struct i2c_adapter *adapter, u16 addr,
 			msg[1].flags |= I2C_M_RECV_LEN;
 			msg[1].len = 1; /* block length will be added by
 					   the underlying bus driver */
-			i2c_smbus_try_get_dmabuf(&msg[1], 0);
 		} else {
 			msg[0].len = data->block[0] + 2;
 			if (msg[0].len > I2C_SMBUS_BLOCK_MAX + 2) {
@@ -400,10 +375,8 @@ static s32 i2c_smbus_xfer_emulated(struct i2c_adapter *adapter, u16 addr,
 					data->block[0]);
 				return -EINVAL;
 			}
-
-			i2c_smbus_try_get_dmabuf(&msg[0], command);
 			for (i = 1; i < msg[0].len; i++)
-				msg[0].buf[i] = data->block[i - 1];
+				msgbuf0[i] = data->block[i-1];
 		}
 		break;
 	case I2C_SMBUS_BLOCK_PROC_CALL:
@@ -415,16 +388,12 @@ static s32 i2c_smbus_xfer_emulated(struct i2c_adapter *adapter, u16 addr,
 				data->block[0]);
 			return -EINVAL;
 		}
-
 		msg[0].len = data->block[0] + 2;
-		i2c_smbus_try_get_dmabuf(&msg[0], command);
 		for (i = 1; i < msg[0].len; i++)
-			msg[0].buf[i] = data->block[i - 1];
-
+			msgbuf0[i] = data->block[i-1];
 		msg[1].flags |= I2C_M_RECV_LEN;
 		msg[1].len = 1; /* block length will be added by
 				   the underlying bus driver */
-		i2c_smbus_try_get_dmabuf(&msg[1], 0);
 		break;
 	case I2C_SMBUS_I2C_BLOCK_DATA:
 		if (data->block[0] > I2C_SMBUS_BLOCK_MAX) {
@@ -436,13 +405,10 @@ static s32 i2c_smbus_xfer_emulated(struct i2c_adapter *adapter, u16 addr,
 
 		if (read_write == I2C_SMBUS_READ) {
 			msg[1].len = data->block[0];
-			i2c_smbus_try_get_dmabuf(&msg[1], 0);
 		} else {
 			msg[0].len = data->block[0] + 1;
-
-			i2c_smbus_try_get_dmabuf(&msg[0], command);
 			for (i = 1; i <= data->block[0]; i++)
-				msg[0].buf[i] = data->block[i];
+				msgbuf0[i] = data->block[i];
 		}
 		break;
 	default:
@@ -465,20 +431,15 @@ static s32 i2c_smbus_xfer_emulated(struct i2c_adapter *adapter, u16 addr,
 			msg[num-1].len++;
 	}
 
-	status = __i2c_transfer(adapter, msg, num);
+	status = i2c_transfer(adapter, msg, num);
 	if (status < 0)
-		goto cleanup;
-	if (status != num) {
-		status = -EIO;
-		goto cleanup;
-	}
-	status = 0;
+		return status;
 
 	/* Check PEC if last message is a read */
 	if (i && (msg[num-1].flags & I2C_M_RD)) {
 		status = i2c_smbus_check_pec(partial_pec, &msg[num-1]);
 		if (status < 0)
-			goto cleanup;
+			return status;
 	}
 
 	if (read_write == I2C_SMBUS_READ)
@@ -495,22 +456,15 @@ static s32 i2c_smbus_xfer_emulated(struct i2c_adapter *adapter, u16 addr,
 			break;
 		case I2C_SMBUS_I2C_BLOCK_DATA:
 			for (i = 0; i < data->block[0]; i++)
-				data->block[i + 1] = msg[1].buf[i];
+				data->block[i+1] = msgbuf1[i];
 			break;
 		case I2C_SMBUS_BLOCK_DATA:
 		case I2C_SMBUS_BLOCK_PROC_CALL:
-			for (i = 0; i < msg[1].buf[0] + 1; i++)
-				data->block[i] = msg[1].buf[i];
+			for (i = 0; i < msgbuf1[0] + 1; i++)
+				data->block[i] = msgbuf1[i];
 			break;
 		}
-
-cleanup:
-	if (msg[0].flags & I2C_M_DMA_SAFE)
-		kfree(msg[0].buf);
-	if (msg[1].flags & I2C_M_DMA_SAFE)
-		kfree(msg[1].buf);
-
-	return status;
+	return 0;
 }
 
 /**
@@ -526,39 +480,14 @@ static s32 i2c_smbus_xfer_emulated(struct i2c_adapter *adapter, u16 addr,
  * This executes an SMBus protocol operation, and returns a negative
  * errno code else zero on success.
  */
-s32 i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,
-		   unsigned short flags, char read_write,
-		   u8 command, int protocol, union i2c_smbus_data *data)
+s32 i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr, unsigned short flags,
+		   char read_write, u8 command, int protocol,
+		   union i2c_smbus_data *data)
 {
-	s32 res;
-
-	res = __i2c_lock_bus_helper(adapter);
-	if (res)
-		return res;
-
-	res = __i2c_smbus_xfer(adapter, addr, flags, read_write,
-			       command, protocol, data);
-	i2c_unlock_bus(adapter, I2C_LOCK_SEGMENT);
-
-	return res;
-}
-EXPORT_SYMBOL(i2c_smbus_xfer);
-
-s32 __i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,
-		     unsigned short flags, char read_write,
-		     u8 command, int protocol, union i2c_smbus_data *data)
-{
-	int (*xfer_func)(struct i2c_adapter *adap, u16 addr,
-			 unsigned short flags, char read_write,
-			 u8 command, int size, union i2c_smbus_data *data);
 	unsigned long orig_jiffies;
 	int try;
 	s32 res;
 
-	res = __i2c_check_suspended(adapter);
-	if (res)
-		return res;
-
 	/* If enabled, the following two tracepoints are conditional on
 	 * read_write and protocol.
 	 */
@@ -569,26 +498,22 @@ s32 __i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,
 
 	flags &= I2C_M_TEN | I2C_CLIENT_PEC | I2C_CLIENT_SCCB;
 
-	xfer_func = adapter->algo->smbus_xfer;
-	if (i2c_in_atomic_xfer_mode()) {
-		if (adapter->algo->smbus_xfer_atomic)
-			xfer_func = adapter->algo->smbus_xfer_atomic;
-		else if (adapter->algo->master_xfer_atomic)
-			xfer_func = NULL; /* fallback to I2C emulation */
-	}
+	if (adapter->algo->smbus_xfer) {
+		i2c_lock_bus(adapter, I2C_LOCK_SEGMENT);
 
-	if (xfer_func) {
 		/* Retry automatically on arbitration loss */
 		orig_jiffies = jiffies;
 		for (res = 0, try = 0; try <= adapter->retries; try++) {
-			res = xfer_func(adapter, addr, flags, read_write,
-					command, protocol, data);
+			res = adapter->algo->smbus_xfer(adapter, addr, flags,
+							read_write, command,
+							protocol, data);
 			if (res != -EAGAIN)
 				break;
 			if (time_after(jiffies,
 				       orig_jiffies + adapter->timeout))
 				break;
 		}
+		i2c_unlock_bus(adapter, I2C_LOCK_SEGMENT);
 
 		if (res != -EOPNOTSUPP || !adapter->algo->master_xfer)
 			goto trace;
@@ -604,13 +529,13 @@ s32 __i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,
 trace:
 	/* If enabled, the reply tracepoint is conditional on read_write. */
 	trace_smbus_reply(adapter, addr, flags, read_write,
-			  command, protocol, data, res);
+			  command, protocol, data);
 	trace_smbus_result(adapter, addr, flags, read_write,
 			   command, protocol, res);
 
 	return res;
 }
-EXPORT_SYMBOL(__i2c_smbus_xfer);
+EXPORT_SYMBOL(i2c_smbus_xfer);
 
 /**
  * i2c_smbus_read_i2c_block_data_or_emulated - read block or emulate
@@ -668,57 +593,3 @@ s32 i2c_smbus_read_i2c_block_data_or_emulated(const struct i2c_client *client,
 	return i;
 }
 EXPORT_SYMBOL(i2c_smbus_read_i2c_block_data_or_emulated);
-
-/**
- * i2c_setup_smbus_alert - Setup SMBus alert support
- * @adapter: the target adapter
- * @setup: setup data for the SMBus alert handler
- * Context: can sleep
- *
- * Setup handling of the SMBus alert protocol on a given I2C bus segment.
- *
- * Handling can be done either through our IRQ handler, or by the
- * adapter (from its handler, periodic polling, or whatever).
- *
- * NOTE that if we manage the IRQ, we *MUST* know if it's level or
- * edge triggered in order to hand it to the workqueue correctly.
- * If triggering the alert seems to wedge the system, you probably
- * should have said it's level triggered.
- *
- * This returns the ara client, which should be saved for later use with
- * i2c_handle_smbus_alert() and ultimately i2c_unregister_device(); or NULL
- * to indicate an error.
- */
-struct i2c_client *i2c_setup_smbus_alert(struct i2c_adapter *adapter,
-					 struct i2c_smbus_alert_setup *setup)
-{
-	struct i2c_board_info ara_board_info = {
-		I2C_BOARD_INFO("smbus_alert", 0x0c),
-		.platform_data = setup,
-	};
-
-	return i2c_new_device(adapter, &ara_board_info);
-}
-EXPORT_SYMBOL_GPL(i2c_setup_smbus_alert);
-
-#if IS_ENABLED(CONFIG_I2C_SMBUS) && IS_ENABLED(CONFIG_OF)
-int of_i2c_setup_smbus_alert(struct i2c_adapter *adapter)
-{
-	struct i2c_client *client;
-	int irq;
-
-	irq = of_property_match_string(adapter->dev.of_node, "interrupt-names",
-				       "smbus_alert");
-	if (irq == -EINVAL || irq == -ENODATA)
-		return 0;
-	else if (irq < 0)
-		return irq;
-
-	client = i2c_setup_smbus_alert(adapter, NULL);
-	if (!client)
-		return -ENODEV;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(of_i2c_setup_smbus_alert);
-#endif
